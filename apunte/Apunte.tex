
% ******** Meta ******** %

\documentclass{article}
\usepackage[paper=a4paper, 
		    left=2cm, 
			right=2cm, 
			bottom=2.5cm, 
			top=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[colorlinks = true, linkcolor=color1]{hyperref}

% ******** Font ******** %

\usepackage[T1]{fontenc}
\usepackage{lmodern}\fontfamily{cmtt}
\usepackage{dirtytalk}

% ******** Color ******** %

\usepackage{xcolor}
\definecolor{color1}{RGB}{220,55,130}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% ******** Envs ******** %

\newcommand{\imp}[1]{\textcolor{color1}{#1}}

\usepackage{enumitem}
\setlist[itemize]{label=\textcolor{color1}{\tiny $\blacksquare$}}
\renewcommand{\labelenumi}{\textcolor{color1}{\arabic{enumi}.}}
\renewcommand{\labelenumii}{\textcolor{color1}{\arabic{enumi}.\arabic{enumii}}}
\renewcommand{\labelenumiii}{\textcolor{color1}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}}

\usepackage{listings}

\usepackage{listings}
\lstdefinestyle{mystyle}{
    commentstyle=\color{codegray},
    keywordstyle=\color{color1},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{color1},
    basicstyle=\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=4pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,     
    tabsize=2,
	frame=leftline, 
	framexleftmargin=5mm,
	frame=shadowbox,
	rulesepcolor=\color{color1},
	captionpos=t,
	xleftmargin=.05\textwidth,
	xrightmargin=.02\textwidth
}

\lstset{style=mystyle}

\lstset{
    language=Haskell,
    literate=
    {谩}{{\'a}}1 {茅}{{\'e}}1 {铆}{{\'i}}1 {贸}{{\'o}}1 {煤}{{\'u}}1
    {}{{\'A}}1 {}{{\'E}}1 {}{{\'I}}1 {}{{\'O}}1 {}{{\'U}}1
    {帽}{{\~n}}1 {}{{$\oplus$}}1 {}{{$\forall$}}1
}


% ******** Math ******** %

\usepackage{amsmath}
\usepackage{amssymb}

% ******** Doc Format ******** %

\addto\captionsspanish{
	\renewcommand{\contentsname}{Contenidos}
}

% ******** Headers ******** %

\usepackage{fancyhdr}\setlength{\headheight}{15.5pt}
\pagestyle{fancy}

\fancyheadinit{\color{color1}}
\fancyfootinit{\color{color1}}
\fancyhead[C,R]{}
\fancyhead[L]{\leftmark}
\fancyfoot[L,C]{}
\fancyfoot[R]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}


% ******** Body ******** %

\title{\Huge Abordaje funcional a EDSLs}
\author{Lucas Di Salvo}
\date{ECI 37 - 2024}

\begin{document}

\maketitle

\tableofcontents

\thispagestyle{empty}

\newpage

\section{Introducci贸n}\label{sec:introduccion}

Un lenguaje de dominio espec铆fico (DSL) es un lenguaje de programaci贸n o especificaci贸n de expresividad limitada, especialmente dise帽ado para resolver problemas en un particular dominio. Por ejemplo
\begin{itemize}
\item HTML
\item VHDL (hardware)
\item Mathematica, Maple
\item SQL, XQuery (lenguajes de query)
\item Yacc y Lex (para generaci贸n de parser)
\item \LaTeX (para producir documentos)
\item DSLs para aplicaciones financieras (\url{http://www.dslfin.org})
\end{itemize}
Existen dos abordajes principales para implementar DSLs:

\begin{itemize}
\item \imp{Externo}: Lenguaje standalone donde es necesario desarrollar lexer, parser, compilador, y dem谩s herramientas.
\item \imp{Interno}: Lenguaje implementado en el contexto de otro (embebido).
\end{itemize}

\subsection{DSLs embebidos}\label{subsec:dsls_embebidos}

Los \imp{Embedded DSLs} (EDSLs) son DSLs implementados como bibliotecas espec铆ficas en lenguajes de prop贸sito general que actuan como anfitri贸n (host languages). De esta manera el EDSL puede hacer uso de la infraestructura y facilidades existentes en el lenguaje anfitri贸n.

\

La implementacion de un EDSL suele reducir el costo de desarrollo (se evita implementar lexer, parser, etc), y los lenguajes funcionales, en particular Haskell, son muy
apropiados para la implementaci贸n de EDSLs. Es relevante mencionar que el manejo de errores suele ser un punto debil de los EDSLs. Algunos ejemplos de EDSLs en Haskell son:

\begin{itemize}
\item Quickcheck
\item Sequence (finger trees)
\item Streams
\item HaXml (procesamiento de XML, HTML)
\item Lava (hardware description)
\item Parsec (parsing)
\item Pretty printing
\item Haskore (para componer m煤sica)
\end{itemize}

\newpage

\section{Tipos de EDSLs}\label{sec:tipos_de_edsls}
    
\noindent Los EDSLs se caracterizan por tener:

\begin{itemize}
\item Shallow embedding
\begin{itemize}
\item Se captura directamente en un tipo de dato la sem谩ntica de los datos del dominio.
\item Se elige un tipo concreto de manera explicita, cuya interpretaci贸n es fija.
\item Las operaciones del DSL manipulan directamente los valores del dominio.
\end{itemize}
\item Deep embedding
\begin{itemize}
\item Las construcciones del DSL son representadas como t茅rminos de tipos de datos que corresponden a 谩rboles de sintaxis abstracta (AST).
\item Est谩 m谩s cerca de un lenguaje standanlone.
\item Los t茅rminos son luego recorridos para su evaluaci贸n
\item No hay una sem谩ntica fija, sino que se pueden definir diferentes interpretaciones.
\item Las operaci贸n dictan la sem谩ntica.
\end{itemize}
\end{itemize}

\subsection*{Ejemplo de EDSL}

Consideremos un lenguaje que manipula expresiones aritm茅ticas formado por las siguientes operaciones:

\begin{lstlisting}
val :: Int -> Expr           -- Constuctor, 
                             -- todo entero es una expresi贸n
add :: Expr -> Expr -> Expr  -- Constructor, 
                             -- la suma de expresiones es una expresi贸n
eval :: Expr -> Int          -- Observador, evalua una expresi贸n
\end{lstlisting}

Ejemplo de un programa en el DSL:

\begin{lstlisting}
siete :: Expr
siete = add (val 3) (val 4)

dovle :: Expr -> Expr
doble e = add e e

runDoble :: Expr -> Int
run Doble e = eval (doble e)
\end{lstlisting}

\section{Shallow Embedding}\label{sec:shallow_embedding}

\noindent Se captura directamente la sem谩ntica del dominio que manipula el DSL. Para este tipo de expresiones aritm茅ticas, la representaci贸n por defecto es usar un entero, el cu谩l va a denotar el valor de la expresi贸n.

\

\begin{lstlisting}
type Expr = Int
-- Constructores
val n    = n
add e e' = e + e'
-- Observador
eval e = e
\end{lstlisting}

\section{Deep Embedding}\label{sec:deep_embedding}

\noindent Se definen las formas de construir expresiones a trav茅s de un tipo

\begin{lstlisting}
data Expr where
  Val :: Int -> expr
  Add :: Expr -> Expr -> Expr
\end{lstlisting}
Operaciones de construcci贸n (smart constructors, se usan para ocultar la implementaci贸n
interna):
\begin{lstlisting}
val :: Int -> Expr
val n = Val n
  
add :: Expr -> Expr -> Expr
add e e' = Add e e'
\end{lstlisting}
El observador ahora hace las veces de funci贸n de interpretaci贸n
\begin{lstlisting}
eval :: Expr -> Int
eval (Val n)    = n
eval (Add e e') = eval e + eval e'
\end{lstlisting}


\section{驴Qu茅 embedding elegir? (expression problem)}\label{sec:expression_problem}


\begin{itemize}
\item[] \imp{Shallow embedding}
\begin{itemize}
\item[] \imp{Pros}: Es simple agregar nuevas construcciones al EDSL (por ejemplo, mult), mientras se puedan representar en el dominio de interpretaci贸n
\item[] \imp{Cons}: Agregar nuevas formas de interpretaci贸n (por ejemplo, hacer un pretty printing de las expresiones) puede implicar una reimplementaci贸n completa. Adicionalmente, los constructores ya evaluan.
\end{itemize}
\item[] \imp{Deep embedding}
\begin{itemize}
\item[] \imp{Pros}: Es simple agregar un nuevo observador (por ejemplo, pretty printing).
\item[] \imp{Cons}: Agregar nuevas construcciones al lenguaje (como mult) implica modificar el tipo del AST (el tipo \texttt{Expr})  reimplementar todos los observadores (las funciones de interpretaci贸n).
\end{itemize}
\end{itemize}

\section{Razonamiento sobre EDSLs}\label{sec:razonamiento_sobre_edsls}

\noindent A partir de la definici贸n del EDSL en Haskell (tanto como shallow o deep embedding) es posible probar propiedades del EDSL. Por ejemplo:
\begin{center}
\texttt{add e (add e' e'') = add (add e e') e''} \\
\texttt{add e e' = add e' e}
\end{center}

\newpage

\section{Tipos Algebr谩icos}\label{sec:tipos_algebraicos}

\begin{lstlisting}
-- Notaci贸n de Generalized Algebraic Data Types (GADTs):
data Expr where
  Val :: Int -> Expr
  Add :: Expr -> Expr -> Expr
    
-- Notaci贸n cl谩sica
data Expr = Val Int | Add Expr Expr
\end{lstlisting}

En general:
\begin{lstlisting}
data T a_1 ... a_m = C_1 t_11 ... t_1k_1
                     ...
                   | C_n t_n1 ... t_nk_n
\end{lstlisting}                   

Donde las variables \texttt{a\_i} puede ser usadas en la definici贸n de los constructores. Y se tiene una manera simple de definir estructuras arborescentes:

\begin{lstlisting}
data Tree a = Leaf a | Fork (Tree a) (Tree a)

data Tree a where
  Leaf :: a -> Tree a
  Fork :: Tree a -> Tree a -> Tree a
\end{lstlisting}

Los t茅rminos de un lenguaje son estructuras arborescentes.

\subsection{Constructores}\label{subsec:gadts_constructores}

\begin{lstlisting}
-- Los constructores se introducen al definir el tipo.
data Expr where
  Val :: Int -> Expr
  Add :: Expr -> Expr -> Expr
-- Tambi茅n puede definir "smart" constructors
val = Val
add = Add
  
val x | x >= 0 = val x
\end{lstlisting}
\subsection{Observadores}\label{subsec:gadts_observadores}

\begin{lstlisting}
-- Dado el tipo:
data Expr where
  Val :: INt -> Expr
  Add :: Expr -> Expr -> Expr    
-- Puedo definir observadores (funciones) por casos, 
-- usando patter-matching y recursi贸n
eval :: Expr -> Int
eval (Val x)   = x
eval (Add x y) = eval x + eval y
\end{lstlisting}

Los patrones satisfacen la gram谩tica:

\[pat~::= ~\_ ~|~variable~|~literal~|~(pat_1, \ldots, pat_m)~|~pat:pat~|~C~pat_1~\ldots~pat_n~|~var@pat\]
          
\section{Observadores - Alto Orden}\label{sec:observadores_alto_orden}

\noindent Multiples observadores puede compartir un patr贸n de recursi贸n:
\begin{lstlisting}
eval :: Expr -> Int
eval (Val x)   = x
eval (Add x y) = eval x + eval y

cantVals :: Expr -> Int
cantVals (Val _)   = 1
cantVals (Add x y) = cantVals x + cantVals y

ppExpr :: Expr -> String
ppExpr (Val x)   = show x
ppExpr (Add x y) = ppExpr x ++ " + " ++ ppExpr y

\end{lstlisting}

Puedo defirnir funciones de alto orden para capturar ese patr贸n
\begin{lstlisting}
foldExpr :: (Int -> a) -> (a -> a -> a) -> Expr -> a
foldExpr fv _  (Val x)   = fv x
foldExpr fv fa (Add x y) = fa (rec x) (rec y)
  where rec = foldExpr fv fa
-- Luego se puede definir:
eval     = foldExpr id (+)
cantVals = foldExpr (const 1) (+)
ppExpr   = foldExpr show (\ppx ppy -> ppx ++ " + " ++ ppy)
\end{lstlisting}

\subsection{Alto Orden en Shallow Embedding}\label{subsec:alto_orden_shallow_embedding}

Agregamos variables a nuestro lenguaje de expresiones:

\begin{lstlisting}
val :: Int -> Expr
add :: Expr -> Expr -> Expr
var :: String -> Expr
\end{lstlisting}  

Nuestro evaluador deber铆a poder aplicar el ambiente de variables:

\begin{lstlisting}
eval :: Expr -> [(String, Int)] -> Int
\end{lstlisting}

Entonces el tipo Expr es:

\begin{lstlisting}
type Expr = [(String, Int)] -> Int
\end{lstlisting}

y los constructores son funciones de alto orden

\begin{lstlisting}
val x   = \_   -> x
add x y = \env -> x env + y env
var v   = \env -> slookup v env  -- funci贸n placeholder para lookup
\end{lstlisting}

\newpage

\section{Type classes}\label{sec:type_classes}

\noindent Podemos empaquetar la API del lenguaje en una type class:
\begin{lstlisting}
class IExpr e where
  val  :: Int -> e
  add  :: e -> e -> e
  eval :: e -> Int
\end{lstlisting}

Definiendo instancias para cada implementaci贸n:

\begin{lstlisting}
data Expr = Val Int | Add Expr Expr

instance IExpr Expr where
  val = Val
  add = Add
  eval = foldExpr id (+)
    
instance IExpr Int where
  val n  = n
  add x  = x + y
  eval e = e
\end{lstlisting}

\section{Ejeplo - Regiones geom茅tricas}\label{sec:ejemplo_regiones_geometricas}

\noindent Consideremos un lenguaje que manipula regiones ge贸metricas formado por las siguientes operaciones:

\begin{lstlisting}
class Region r where
  inRegion   :: Point -> r -> Bool --observador
  circle     :: Radius -> r
  outside    :: r -> r
  union      :: r -> r -> r
  interesect :: r -> r -> r
\end{lstlisting}

Ejemplo de un program en el DSL

\begin{lstlisting}
aro :: Region r => Radius -> Radius -> r
aro r1 r2 = outside (circle r1) `intersect` circle r2
\end{lstlisting}
  
\subsection{Shallow embedding}

Se captura directamente la sem谩ntica del dominio que manipula el DSL, en este caso regiones.

\

Una regi贸n geometrica se va a representar por la funci贸n caracter铆stica del conjunto de puntos (dice que puntos est谩n y cuales no)

\begin{lstlisting}
data SRegion = R (Point -> Bool)
-- y la instancia
instance Region SRegion where
  p `inRegion` (R r)       = r p
  circle r                 = R $ \p -> magnitude p =< r
  outside (R r)            = R $ \p -> not (r p)
  (R r) `union` (R r')     = R $ \p -> r p || r' p
  (R r) `intersect` (R r') = R $ \p -> r p && r' p
\end{lstlisting}

\subsection{Deep embedding}

Se definen las formas de construir regiones a trav茅s de un tipo

\begin{lstlisting}
data DRegion = Circle Radius
             | Outside DRegion
             | Union DRegion DRegion
             | Intersect DRegion DRegion
-- y la instancia
instance Region DRegion where
  circle r         = Circle r
  outside r        = Outside r
  r `union` r'     = Union r r'
  r `intersect` r' = Intersect r r'
  p `inRegion` (Circle r)       = magnitude p <= r
  p `inRegion` (Outside r)      = not (p `inRegion` r)
  p `inRegion` (Union r r')     = p `inRegion` r || p `inRegion` r'
  p `inRegion` (Intersect r r') = p `inRegion` r && p `inRegion` r'
\end{lstlisting}

donde la implementaci贸n del esquema de recursi贸n estructural para \texttt{DRegion} es

\begin{lstlisting}
foldRegion :: Region r => (Radius -> a) -> (a -> a) -> (a -> a -> a) 
                                        -> (a -> a -> a) -> r -> a
foldRegion fCir fOut fUni fInt reg = case reg of
    Circle rad          -> fCir $ rec rad
    Outside reg'        -> fOut $ rec reg'
    Union reg1 reg2     -> fUni (rec reg1) (rec reg2)
    Intersect reg1 reg2 -> fInt (rec reg1) (rec reg2)
  where
    rec = foldRegion fCir fOut fUn fInt
\end{lstlisting}

\section{Parser aplicativos}\label{sec:parser_aplicativos}

\subsection{Combinadores de parsing}\label{subsec:sombinadores_de_parsing}

Los combinadores de parsing forman un EDSL que es implementado usando un shallow embedding. Est谩n formados por dos grupos de funciones:

\begin{itemize}
\item Funciones b谩sicas que sirven para reconocer determinados strings de entrada.
\item Un grupo de combinadores que permiten construir nuevos parsers a partir de otros.
\end{itemize}

\imp{\emph{Comentario}}: Los parsers no son totales.

\subsubsection{Parser elementales}

La mayor铆a de las bibliotecas de parsing est谩n formadas por los siguientes 4 combinadores b谩sicos, que se usaran para distintos elementos de la gram谩tica.:

\begin{itemize}
\item String vac铆o \texttt{pSuceed}, para la cadena vac铆a.
\item Terminales \texttt{pSym s}, para literales terminales
\item Alternativa \texttt{p$_1$ <|>~p$_2$}, para optar por un parser u otro
\item Composici贸n \texttt{p$_1$ <*>~p$_2$}, para composici贸n de parsers.
\end{itemize}

\subsubsection{El tipo de un parser}

Un parser puede ser entendido como una funci贸n que toma un string de entrada y retorna algo de tipo \imp{\texttt{a}}:

\begin{lstlisting}
String -> a
\end{lstlisting}

Un parser podr铆a ser ambiguo (si la gram谩tica es ambigua, el parser lo ser谩) y retornar varios posibles valores, significando que puede haber varias formas de reconocer la entrada. En este caso la lista vac铆a podr铆a tomarse como una falla.

\begin{lstlisting}
String -> [a]
\end{lstlisting}

A su vez, un parser podr铆a no consumir toda la entrada y retornar adem谩s la parte de la entrada no consumida, para asociar el resultado del c贸mputo de cada parser a cada cadena (ya que el parser puede bien no ser determinista).

\begin{lstlisting}
String -> [(a, String)]
\end{lstlisting}

En resumen, 

\begin{lstlisting}
type Parser a = String -> [(a, String)]
\end{lstlisting}

y podemos abstraer el tipo \imp{\texttt{String}} de forma:

\begin{lstlisting}
type Parser s a = Eq s => [s] -> [(a, [s])]
\end{lstlisting}

\emph{i.e.} en su lugar ponemos ua lista de valores de tipo \imp{\texttt{s}}, donde a los mismos les vamos a requerir que sean comparables por igualdad (instancia de la clase \imp{\texttt{Eq}})

\subsubsection{Combinadores b谩sicos}

\begin{lstlisting}
pFail    ::                                    Parser s a
pSucceed :: a                               -> parser s a
pSym     :: Eq s => s                       -> Parser s s
<|>      :: Parser s a        -> Parser s a -> Parser s a
<*>      :: Parser s (a -> b) -> Parser s a -> Parser s b
\end{lstlisting}

Para cada uno de ellos escribo su definici贸n

\begin{lstlisting}
pFail :: Parser s a                                      -- Falla
pFail = \_ -> []

pSucceded :: a -> Parser s a                             -- xito
pSucceed a = \cs -> [(a, cs)]

pSym :: Eq s => s -> Parser s s                          -- S铆mbolo
pSym s = \cs -> case cs of
    []      -> []
    (c:cs') -> if c == s
               then [(c, cs')]  -- encontr贸 el s铆mbolo
               else []          -- falla

(<|>) :: Parser s a -> Parser s a -> Parser s a          -- Alternativa
p <|> q = \cs -> p cs ++ q cs

(<*>) :: Parser s (a -> b) -> Parser s a -> Parser s b   -- Composici贸n
(p <*> q) = \cs -> [(f a, cs'') | (f, cs')  <- p cs
                                , (a, cs'') <- q cs']
\end{lstlisting}

\subsubsection{Ejemplos de parsers}

\begin{itemize}
\item Reconocer una \texttt{'A'} y retornar una \texttt{'B'}:
\begin{lstlisting}
pA2B = pSucceed (\_ -> 'B') <*> pSym 'A'
\end{lstlisting}
\item Reconocer una \texttt{'A'}, seguida de una \texttt{'B'}, y retornar ambos caracteres en un par:
\begin{lstlisting}
pAB = pSucceed (,) <*> pSym 'A' <*> pSym 'B'
\end{lstlisting}
\item Parser que retorna una \emph{lista} de valores de tipo \texttt{a}. Toma como par谩metro un parser que retorna un \texttt{a}.
\begin{lstlisting}
pList :: Parser s a -> Parser s [a]
pList p = pSucceed (:) <*> p <*> pList p
          <|>
          pSucceed []
\end{lstlisting}
\item Parser que reconoce u nstring de la forma \texttt{(AB)*}
\begin{lstlisting}
pListAB = pList pAB
\end{lstlisting}
\end{itemize}

\subsubsection{Otros combinadores 煤tiles}

\begin{lstlisting}
(<$>) :: (a -> b) -> Parser s a -> Parser s b
f <$> p = pSucceed f <*> p

opt :: Parser s a -> a -> Parser s a
p `opt` a = p <|> pSucceed a

pSat :: (s -> Bool) -> Parser s a
pSat p = \cs -> case cs of
                    []      -> []
                    (c:cs') -> if p c
                               then [(c, cs')] 
                               else []
\end{lstlisting}

\begin{itemize}
\item Definici贸n de \imp{pAB} usando \texttt{<\$>}

\begin{lstlisting}
pAB = (,) <$> pSym 'A' <*> 'B'
\end{lstlisting}
\item Definici贸n de \imp{Psym} usando \imp{pSat}

\begin{lstlisting}
pSym a = pSat (== a)
\end{lstlisting}
\item Reconocer un d铆gito

\begin{lstlisting}
pDigit = pSat isDigit
  where isDigit c = (c >= '0') && (c <= '9')
\end{lstlisting}
\item Definici贸n de \imp{pList} usando \texttt{<\$>} y \imp{opt}

\begin{lstlisting}
pList p = (:) <$> p <*> pList p `opt` []
\end{lstlisting}
\end{itemize}

\subsubsection{Selecci贸n de resultados de parser}

\begin{lstlisting}
(<*) :: Parser s a -> Parser s b -> Parser s a
p <* q = (\x _ -> x) <$> p <*> q

(*>) :: Parser s a -> Parser s b -> Parser s b
p *> q = (\_ y -> y) <$> p <*> q

(<$) :: a -> Parser s b -> Parser s a
a <$ q = pSucceed a <* q
\end{lstlisting}

Ejemplo, reconocer algo entre par茅ntesis
\begin{lstlisting}
pParens p = pSym '(' *> p <* pSym ')'
\end{lstlisting}
\section{Functor}\label{sec:functor}

\noindent Un \imp{functor} puede entenderse como un constructor de tipo \texttt{f :: * $\rightarrow$ *} (se lee como de \emph{aster} en \emph{aster}, representa el tipo del tipo) junto a una funci贸n de tipo 
\[(a  \rightarrow b) \rightarrow f~a \rightarrow f~b\]
que permite mapear/reemplazar los valores de tipo \imp{\texttt{a}} contenidos en una estructura de tipo \imp{\texttt{f a}} por valores de tipo \imp{\texttt{b}}. En Haskell el concepto de functor es capturado por una clase:


\begin{lstlisting}
class Functor (f :: * -> *) where
    fmap :: (a -> b) -> f a -> f b
\end{lstlisting}

Para ser efectivamente un functor la funci贸n fmap debe satisfacer las siguientes propiedades:

\begin{lstlisting}
fmap id    = id
fmap (f.g) = fmap f . fmap g
\end{lstlisting}
que deber铆an ser chequeadas al definir las instancias de la clase.

\subsection{Ejemplos}

\begin{lstlisting}
instance Functor [] where
    fmap = map

instance Functor Maybe where
    fmap f Nothing  = Nothing
    fmap f (Just a) = Just (f a)
    
    
instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x)  = Left x
    
instance Functor ((->) r) where
    fmap f h = \r -> f (h r)       -- o sea, f.h
\end{lstlisting}

\subsection{Modelando Error con Maybe}\label{subsec:modelando_error_con_maybe}

\begin{lstlisting}
divM x y | y /= 0    = Just (x `div` y)
         | otherwise = Nothing
\end{lstlisting}

Con fmap se puede aplicar una funci贸n pura al resultado de una divisi贸n

\begin{lstlisting}
foo x y = fmap (+2) (divM x y)
\end{lstlisting}

en lugar de hacer:

\begin{lstlisting}
foo x y = case divM x y of
    Just r  -> Just (r+2)
    Nothing -> Nothing
\end{lstlisting}

\section{Functores Aplicativos}\label{sec:functores_aplicativos}

\noindent Los \imp{functores aplicativos} son functores que permiten modelar efectos al aplicar funciones dentro del functor (lo que les da el mote de aplicativos)

\begin{lstlisting}
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{lstlisting}

Se debe cumplir que:

\begin{lstlisting}
fmap f x = pure f <*> x
\end{lstlisting}

Sin贸nimo en \imp{Applicative}:

\begin{lstlisting}
(<$>) :: Functor f => (a -> b) -> f a -> f b
f <$> t = fmap f t
\end{lstlisting}

\subsection{Ejemplo: Maybe}

\begin{lstlisting}
instance Applicative Maybe where
    pure = Just
    (Just f) <*> (Just x) = Just (f x)
    -        <*> -        = Nothing
\end{lstlisting}

Puedo por ejemplo modelar expresiones con errores:

\begin{lstlisting}
type Expr = Maybe Int
valE x = pure x
addE x y = (+) <$> x <*> y
divE x y = case (x,y) of
               (Just vx, Just vy) -> divM vx vy
               _                  -> Nothing
\end{lstlisting}

\subsection{Leyes de functores aplicativos}

\begin{itemize}
\item Identidad:
\begin{center}
\texttt{pure id <*>~u $\equiv$ u}
\end{center}
\item Composici贸n:
\begin{center}
\texttt{pure (.) <*>~u <*>~v <*>~w $\equiv$ u <*>~(v <*>~w)}
\end{center}
\item Homomorfismo:
\begin{center}
\texttt{pure f <*>~pure x $\equiv$ pure (f x)}
\end{center}
\item Intercambio:
\begin{center}
\texttt{u <*>~pure x $\equiv$ pure ($\backslash$f $\rightarrow$ f x) <*>~u}
\end{center}
\end{itemize}
Se cumple entonces
\begin{center}
\texttt{fmap~f~x = pure~f <*> x}
\end{center}

\section{Funciones sobre functores aplicativos}\label{sec:funciones_sobre_functores_aplicativos}

\begin{lstlisting}
sequenceA :: Applicative f => [f a] -> f [a]
sequenceA []     = pure []
sequenceA (a:as) = (:) <$> a <*> sequenceA as

traverse :: Applicative f => (a -> f b) -> [a] -> f [b]
traverse f = sequenceA . fmap f
\end{lstlisting}
    
donde esto 煤ltimo es equivalente a la siguiente definici贸n
\begin{lstlisting}    
traverse f []     = pure []
traverse f (x:xs) = (:) <$> f x <*> traverse f xs
\end{lstlisting}

\section{Alternative}\label{sec:alternative}

\noindent En \imp{Control.Applicative} tambien se define:

\begin{lstlisting}
class Applicative f => Alternative f where
    empty :: f a
    (<|>) :: f a -> f a -> f a
    some  :: f a -> f [a]       -- one or more
    many  :: f a -> f [a]       -- zero or more
\end{lstlisting}

\subsection{Ejemplo de Alternative: Parsers}\label{subsec:ejemplo_de_alternative_parsers}

\begin{lstlisting}
instance Applicative (Parser s) where
    pure = pSucceed
    <*> = <*>

instance Alternative (Parser s) where
    empty = pFail
    <|>   = <|>
    many = pList
    some p = (:) <$> p <*> pList p
\end{lstlisting}

donde

\begin{lstlisting}
pFail :: Parser s a
pSuceed :: a -> Parser s a
<*> :: Parser s (a -> b) -> Parser s a -> Parser s b
<|> :: Parser s a -> Parser s a -> Parser s a
pList :: Parser s a -> Parser s [a]
\end{lstlisting}

\subsubsection{Ejemplo: Listas}

\begin{lstlisting}
instance Applicative [] where
    pure x    = [x]
    fs <*> xs = [f x | f <- fs, x <- xs ]
\end{lstlisting}

Ejemplo:
\begin{lstlisting}
[(+1), (+2)] <*> [1, 2, 3]
\end{lstlisting}
\indent \indent eval煤a a
\begin{lstlisting}
[2, 3, 4, 3, 4, 5]
\end{lstlisting}

\subsubsection{Ejemplo: Either}

\begin{lstlisting}
data Either a b = Left a | Right b

instance Functor (Either e) where
fmap f (Right a) = Right (f a)
fmap f (Left e)  = Left e
\end{lstlisting}

Una posible instancia de Applicative:

\begin{lstlisting}
instance Applicative (Either e) where
    pure                = Right
    Right f <*> Right a = Right (f a)
    Right f <*> Left e  = Left e
    Left e  <*>         = Left e
\end{lstlisting}

Otra:

\begin{lstlisting}
instance Monoid e -> Applicative (Either e) where
    pure = Right
    Right f <*> Right a  = Right (f a)
    Left e  <*> Right    = Left e
    Right   <*> Left e   = Left e
    Left e  <*> Left e 0 = Left (e `mappend` e 0 )
\end{lstlisting}

\subsection{Composici贸n}

La clase de los functores aplicativos es cerrada bajo la composici贸n.

\begin{lstlisting}
newtype (f :. g) a = Compose {getCompose :: f (g a)}

instance (Functor f, Functor g) => FUnctor (f :. g) where
    fmap f (Compose x) = Compose (fmap (fmap f) x)
    
instance (Applicative f, Applicative g) => Applicative (f :. g) where
    pure x                  = Compose (pure (pure x))
    COmpose f <*> Compose x = Compose ((<*>) <$> f <*> x)
\end{lstlisting}

La composisici贸n de dos m贸nadas puede no ser un m贸nada, pero s铆 es un aplicativo.

\newpage

\section{Evaluador con Fallas}

\begin{lstlisting}
eval :: Expr -> Maybe Int
eval (Val n)   = Just n
eval (Add x y) = case eval x of
                     Nothing -> Nothing
                     Just a  -> case eval y of
                                   Nothing -> NOthing
                                   Just b  -> Just (a + b)

eval (Div x y) = case eval x of
                     Nothing -> Nothing
                     Just a  -> case eval y of
                                   Nothing -> Nothing
                                   Just b  -> Just a `divM` b
\end{lstlisting}

\subsection{Evaluador con Fallas - Applicative}

\begin{lstlisting}
eval :: Expr -> Maybe Int
eval (Val n)   = pure n
eval (Add x y) = (+) <$> eval x <*> eval y
eval (Div x y) = case eval x of
                     Nothing -> Nothing
                     Just a  -> case eval y of
                         Nothing -> Nothing 
                         Just b -> a `divM` b`
\end{lstlisting}

No puedo representar la divisi贸n con Functores Aplicativos, necesito el resultado de una computaci贸n para determinar el siguiente efecto.


\subsection{Capturemos patrones}

Primero definimos

\begin{lstlisting}
return :: a -> Maybe a
return a = Just a

(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
m >>= f = case m of
              Nothing -> Nothing
              Just a  -> f a
\end{lstlisting}

Entonces,

\begin{lstlisting}
eval :: Expr -> Mabe Int
eval (Val n)   = return n
eval (Add x y) = eval x >>= (\a -> eval y >>= (\b -> return (a+b)))
eval (Div x y) = eval x >>= (\a -> eval y >>= (\b -> a `dibM` b))
\end{lstlisting}

y escrito de manera similar

\begin{lstlisting}
eval :: Expr -> Mabe Int
eval (Val n)   = return n
eval (Add x y) = eval x >>= \a -> 
                 eval y >>= \b -> 
                 return (a+b)
eval (Div x y) = eval x >>= \a -> 
                 eval y >>= \b -> 
                 a `dibM` b
\end{lstlisting}

\section{La clase Monad}

\begin{lstlisting}
clasee Applicative m => Monad m ehere
(>>=)  :: m a -> (a -> m b) -> m b
(>>)   :: m a -> m b -> m b
return :: a -> m a

-- donde

m >> k = m >>= \_ -> k
\end{lstlisting}

Toda m贸nada es un functor aplicativo que cumple:

\begin{itemize}
\item[]

\begin{lstlisting}
pure = return
\end{lstlisting}

\item[]

\begin{lstlisting}
m1 <*> m2 = m1 >>= (\f -> m2 >>= (\x -> return (f x)))
\end{lstlisting}
\end{itemize}

No todo \imp{functor aplicativo} es una \imp{m贸nada}.

\subsection{M贸nada Maybe}

\begin{lstlisting}
data Maybe a = Just a | Nothing

Instance Monad Maybe where
    return  = Just
    m >>= k = case m of
                  Just x  -> k x
                  Nothing -> Nothing 

instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just a) = Just (f a)
    
instance Applicative Maybe where
    pure                  = Just
    (Just f) <*> (Just x) = Just (f x)
    _        <*> _        = Nothing
    
-- Visto como m贸nada

instance Applicative Maybe where
    pure                  = return
    m1 <*> m2 = m1 >>= (\f -> m2 >>= (\x -> return (f x)))
\end{lstlisting}

\subsection{Leyes de m贸nadas}

\begin{itemize}
\item $return~x \gg = f = f~x$
\item $m \gg = return = m$
\item $(m \gg = f) \gg = g = m \gg = \backslash x \rightarrow (f~x \gg g)$
\end{itemize}

\subsection{Composici贸n funciones mon谩dicas}

Composici贸n de Kleisli

\begin{lstlisting}
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
f >=> g = \a -> f a >>= g
\end{lstlisting}

Propiedades:

\begin{itemize}
\item $return >=> f = f$
\item $f >=> return = f$
\item $f >=> (g >=> h) = (f >=> g) >=> h$
\end{itemize}

\imp{\emph{Nota}}: Estas propiedades se pueden probar usando las leyes de m贸nadas.

\subsection{Notaci贸n do}


\begin{lstlisting}
do m = m
do {x <- m; m'} = m >>= \x -> do m'
do {m; m'}      = m >> do m'
\end{lstlisting}

\subsection{Evaluador con Fallas (notaci贸n do)}

\begin{lstlisting}
eval :: Expr -> Maybe Int
eval (Val n) = return n
eval (Add x y) = do a <- eval x
                    b <- eval y
                    return (a + b)
eval (Div x y) = do a <- eval x
                    b <- eval y
                    a `divM` b
\end{lstlisting}

\newpage

\subsection{Monada Either}

\begin{lstlisting}
data Either a b = Left a | Right b

instance Monad (Either e) where
    return        = Right
    Left e >>=  _ = Left e
    Right a >>= f = f a

-- Se corresponde con:

instance Applicative (Either e) where
    pure                = Right
    Right f <*> Right a = Right (f a)
    Right f <*> Left e  = Left e
    Left e  <*> _       = Left e

-- Pero no con:

instance Monoid e => Applicative (Either e) where
    pure                = Right
    Right f <*> Right a = Right (f a)
    Left e  <*> Right _ = Left e
    Right _ <*> Left e  = Left e
    Left e  <*> Left e' = Left (e `mappend` e')

\end{lstlisting}

\subsubsection{Applicative no mon谩dico}

La instancia anterior de \imp{\texttt{Applicative}} para \imp{\texttt{Either}} \emph{no} es una m贸nada.

\begin{lstlisting}
instance Monoid e => Monad (Either e) where
    return       = Right
    Left e >>= f = ??
    ...
\end{lstlisting}

\begin{itemize}
\item No podemos aplicar f en este caso porque solo se aplica cuando la primera computaci贸n retorna un valor \imp{\texttt{Right} a}
\item Esto no ocurre en la instancia de \imp{\texttt{Applicative}}
\end{itemize}

\subsubsection{Diferencia entre functores aplicativos y m贸nadas}

La diferencia entre se puede apreciar en los siguientes operadores condicionales:

\begin{lstlisting}
ifM :: Monad m => m Bool -> m a -> m a -> m a
ifM mb mt me = do b <- mb
                  if b then mt else me
\end{lstlisting}
No todas computaciones se ejecutan (se elije entre mt y me), pero en este caso 
\begin{lstlisting}
ifA :: Applicative f => f Bool -> f a -> f a -> f a
ifA fb ft fe = cond <$> fb <*> ft <*> fe
  where
    cond b t e = if b then t else e
\end{lstlisting}

Las tres computaciones (fb, ft y fe) se ejecutan y finalmente se elije uno de los resultados.

\subsection{M贸nada de estado}

\begin{lstlisting}
newtype State s a = State (s -> (a, s))

runState :: State s a -> (s -> (a, s))
runState (State f) = f

instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= f  = State $ \s -> let (a, s') = runState m s
                             in runState (f a) s'
\end{lstlisting}

Forma alternativa de escribir la definici贸n de ($\gg=$):

\begin{lstlisting}
(State g) >>= f = State $ \s -> let (a, s') = g s
                                    State k = f a
                                in k s'
\end{lstlisting}

\subsubsection{Funciones sobre estado}

\begin{lstlisting}
get :: State s s
get = State $ \s -> (s, s)

put :: s -> State s ()
put s = State $ \_ -> ((), s)

modify :: (s -> s) -> State s ()
modify f = get >>= \s -> put (f s)

evalState :: State s a -> s -> a
evalState m s = fst $ runState m s

execState :: State s a -> s -> s
execState m s = snd $ runState m s
\end{lstlisting}

\subsubsection{Ejemplo: Contar n煤mero de sumas en una expresi贸n}

\begin{lstlisting}
tick :: State Int ()
tick = modify (+1)

evalS :: Expr -> State Int Int
evalS (Val n)    = return n
evalS (Add e e') = do a <- evalS e
                        b <- evalS e'
                        tick
                        return (a + b)

nroSumas e = execState (evalS e) 0
\end{lstlisting}

\newpage

\subsection{Evaluador con variables}

\begin{lstlisting}
data Expr = Val Int
          | Add Expr Expr
          | Var ID         -- variables
          | Assign ID Expr -- asignaci贸n

eval :: Expr -> State (Map ID Int) Int
eval (Val n)      = return n
eval (Add e e )   = do a <- eval e
                       b <- eval e 0
                       return (a + b)
eval (Var v )     = do s <- get
                       return (fromJust $ lookup v s)
eval (Assign v e) = do a <- eval e
                       s <- get
                       put (insert v a s)
                       return a
\end{lstlisting}

\subsection{M贸nada de estado, otra implementaci贸n}

\begin{lstlisting}
class Monad m -> MonadState s m | m -> s where
    get :: m s
    put :: s -> m ()

modify :: MonadState s m => (s -> s) -> m ()
modify f = do s <- get
              put (f s)

instance MonadState s (State s) where
    get   = State $ \s -> (s, s)
    pu    t s = State $ \_ -> ((), s)
\end{lstlisting}

\subsection{M贸nada Lista}

\begin{lstlisting}
instance Monad [] where
return x = [x]
xs >>= f = [y | x <- xs, y <- f x]
            -- concat (map f xs)
\end{lstlisting}

Ejemplo: Suma de todos los pares de valores de dos listas

\begin{lstlisting}
sumnd :: Num a => [a] -> [a] -> [a]
sumnd xs ys = do x <- xs
                 y <- ys
                 return (x + y)
                 
-- Luego, 
-- >> sumnd [1,3] [4, 7]
--    [5, 8, 7, 10]     
\end{lstlisting}

\section{Parsers Mon谩dicos}\label{sec:parsers_monadicos}

\subsection{M贸nada de Parsing}

\begin{lstlisting}
newtype Parser a = P (String -> [(a, String)])

runP :: Parser a -> String -> [(a, String)]
runP (P p) = p

instance Monad Parser where
    return a    = P $ \cs -> [(a, cs)]
    (P p) >>= f = P $ \cs ->
                  concat [runP (f a) cs' | (a, cs') <- p cs]
\end{lstlisting}

\subsection{Parsing: cobinadores b谩sicos}

\begin{lstlisting}
pFail :: Parser a
pFail = P $ \cs -> []

item :: Parser Char
item = P $ \cs -> case cs of 
    ""     -> []
    (c:cs) -> [(c, cs)]

pSat :: (Char -> Bool) -> Parser Char
pSat p = do c <- item
            if p c then return c else pFail

pSym :: Char -> Parser Char
pSym c = pSat (== c)
\end{lstlisting}

\imp{Definici贸n}: Llamammos \imp{section} a una funci贸n que conoce su segundo argumento pero no el primero.

\subsection{Parsing: Alternativa}

\begin{lstlisting}
(<|>) :: Parser a -> Parser a -> Parser a
(P p) <|> (P q) = P $ \cs -> p cs ++ q cs


-- Otra forma de definir el operador de alternativa:

(P p) <|> (P q) = P $ \cs -> case p cs ++ q cs of
                                 []       -> []
                                 (x : xs) -> [x]
\end{lstlisting}

\newpage

\subsection{Parsing: many y some}

\begin{lstlisting}
-- p* (many) cero o m谩s veces p

pList :: Parser a -> Parser [a]
pList p = do a <- p
             as <- pList p
             return (a:as)
             <|>
             return []

-- p+ (some) una o m谩s veces p

pListP :: Parser a -> Parser [a]
pListP p = do a <- p
              as <- pList p
              return (a:as)
\end{lstlisting}

\subsubsection{Ejemplo: digits}

\begin{lstlisting}
digit :: Parser Int
digit = do c <- pSat isDigit
           return (ord c - ord '0')

isDigit c = (c >= '0') && (c <= '9')

digits :: Parser [Int]
digits = pListP digit

sumDigits :: Parser Int
sumDigits = do ds <- digits
               return (sum ds)
\end{lstlisting}

\subsubsection{Ejemplo: number}

\begin{lstlisting}
number :: Parser Int
number = do d <- digit
            number' d

number' :: Int -> Parser Int
number' n = do d <- digit
               number' (n * 10 + d)
            <|>
            return n

-- Esto equivale a la siguente definici贸n:

number = do (d:ds) <- digits
            return (foldl () d ds)
  where
    n  d = n * 10 + d
\end{lstlisting}

\newpage

\subsection{Parser para expresiones}

Queremos parsear una expresi贸n y retornar el correspondiente 谩rbol
de sintaxis abstracta (AST) de tipo:

\begin{lstlisting}
data Expr = Val Int | Add Expr Expr

-- Que tal este parser?

expr :: Parser Expr
expr = do e1 <- expr
         pSym '+'
         e2 <- expr
         return (Add e1 e2)
       <|>
       do n <- number
          return (Val n)
\end{lstlisting}

\imp{Nota}: Diverge! La recursividad a la izquierda hace que entre en loop.

Para eliminar la recursi贸n a la izquierda debemos basarnos en la
siguiente gram谩tica:
\begin{center}
\texttt{e ::= n + e | n}
\end{center}
\indent \indent El parser queda entonces de la siguiente forma:
\begin{lstlisting}
expr :: Parser Expr
expr = do n <- number
          pSym '+'
          e <- expr
          return (Add (Val n) e)
       <|>
       do n <- number
          return (Val n)
\end{lstlisting}

\section{Parsing y evaluaci贸n de expresiones}

\begin{lstlisting}
evalExpr = do e <- expr
              return (eval e)
\end{lstlisting}
Es posible fusionar las definiciones de eval y expr y obtener una definici贸n de evalExp que computa directamente el valor de la expresi贸n parseada sin generar el AST intermedio:
\begin{lstlisting}
evalExpr :: Parser Int
evalExpr = do n <- number
              pSym '+'
              m <- evalExpr
              return (n + m)
           <|>
           number
\end{lstlisting}

\newpage

\section{Parser de un nano XML}

\begin{lstlisting}
data XML = Tag Char [XML]

xml :: Parser XML
xml = do -- se parsea el tag de apertura
         pSym '<'
         name <- item
         pSym '>'
            -- se parsea la lista de XMLs internos
         xmls <- pList xml
            -- se parsea el tag de cierre
         pSym '<'
         pSym '/'
         pSym name -- se utiliza nombre del tag de apertura
         pSym '>'
         return (Tag name xmls)
\end{lstlisting}

\section{Int茅rpretes Tagless-Final}

\noindent \imp{Tagless-final} es una t茅cnica de tipo \imp{shallow embedding} para embeber lenguajes y sus interpretaciones.

\

Defino el lenguaje como una \imp{clase} que contiene sus constructores:

\begin{lstlisting}
class Expr e where
    val :: Int -> e
    add :: e -> e -> e

expr 1 :: Expr e => e
expr 1 = add (val 8) (add (add (val 2) (val 1)) (val 4))
\end{lstlisting}

\subsection{Int茅rpretes}

\noindent Defino las interpretaciones como \imp{instancias} de la clase

\

Evaluaci贸n:
\begin{lstlisting}
data Eval = E Int

instance Expr Eval where
    val x           = E x
    add (E x) (E y) = E (x + y)
\end{lstlisting}

Pretty-printing:
\begin{lstlisting}
data PP = P String

instance Expr PP where
    val x           = P (show x)
    add (P x) (P y) = P ("(" ++ x ++ "+" ++ y ++ ")")
\end{lstlisting}
No necesito \imp{observadores}.

\subsection{Extensiones al lenguaje}

Puedo \imp{extender} el lenguaje definiendo nuevas clases

\begin{lstlisting}
class ExprMult e where
    mult :: e -> e -> e
    
expr 2 :: (Expr e, ExprMult e) => e
expr 2 = add (mult expr 1 (val 4)) (val 2)
\end{lstlisting}


Definiendo sus interpretaciones
\begin{lstlisting}
instance ExprMult Eval where
    mult (E x) (E y) = E (x * y)

instance ExprMult PP where
    mult (P x) (P y) = P ("(" ++x ++ "*" ++ y ++ ")")
\end{lstlisting}

\subsection{Lenguajes Tipados - Tagged}

Si tenemos un lenguaje con distintos \imp{tipos}

\begin{lstlisting}
class Expr e where
    val    :: Int -> e
    add    :: e -> e -> e
    isZero :: e -> e
    ifE    :: e -> e -> e -> e
\end{lstlisting}
驴C贸mo resolvemos los problemas de tipado?

\

Podriaamos definir funciones \imp{parciales}, o implementar el \imp{type-checking} en el evaluador 

\begin{lstlisting}
data Res = RI Int | RB Bool -- versi贸n Tagged
instance Expr Res where
    val x             = RI x
    add (RI x) (RI y) = RI (x + y)
    isZero (RI x)     = RB (x == 0)
    ifE (RB c) (RI x) (RI y) = RI $ if c then x else y
    ifE (RB c) (RB x) (RB y) = RB $ if c then x else y
\end{lstlisting}

\subsection{Lenguajes Tipados - Tagless}

O podemos codificar el \imp{sistema de tipos} del lenguaje en la clase:

\begin{lstlisting}
class TExpr e where
    valT    :: Int -> e Int
    addT    :: e Int -> e Int -> e Int
    isZeroT :: e Int -> e Bool
    ifT     :: e Bool -> e t -> e t -> e t
\end{lstlisting}

y usar el sistema de tipos del lenguaje anfitri贸n para chequearlo:

\begin{lstlisting}
exprT :: TExpr e => e Int
exprT = ifT (isZeroT (valT 2)) (valT 2) (valT 3)

exprWrong = ifT (valT 1) (valT 2) (valT 3) -- no compila
\end{lstlisting}

\subsection{Int茅rpretes Tipados}

Ahora los int茅rpretes pueden usar la informaci贸n del buen tipado

\begin{lstlisting}
data TEval t = TE t

instance TExpr TEval where
    valT x             = TE x
    addT (TE x) (TE y) = TE (x + y)
    isZeroT (TE x)     = TE (x == 0)
    ifT (TE c) (TE x) (TE y) = TE (if c then x else y)
\end{lstlisting}

o ignorarla a trav茅s de un \imp{phantom type}

\begin{lstlisting}
data TPP a = TP String
instance TExpr TPP where
    valT x             = TP (show x)
    addT (TP x) (TP y) = TP ("(" ++ x ++ "+" ++ y ++ ")")
    isZeroT (TP x)     = TP ("isZero(" ++ x ++ ")")
    ifT (TP c) (TP x) (TP y) = TP ("if " ++ c ++
                                   " then " ++ x ++
                                   " else " ++ y)
\end{lstlisting}


\section{Deep Embeeding de Lenguajes Tipados}

\noindent Volviendo al lenguaje con distintos \imp{tipos}, pero ahora como \imp{deep embedding}

\begin{lstlisting}
data Expr :: * where
    Val    :: Int -> Expr
    Add    :: Expr -> Expr -> Expr
    IsZero :: Expr -> Expr
    If     :: Expr -> Expr -> Expr -> Expr
\end{lstlisting}

\subsection{Evaluador con type-cheking}

Evaluador \imp{parcial}, o con type-checking din谩mico
\begin{lstlisting}
data Res = RI Int | RB Bool

eval :: Expr -> Res
eval (Val n)       = RI n
eval (Add e1 e2)   = case (eval e1, eval e2) of
                         (RI n1, RI n2) -> RI (n1 + n2)
                         _              -> error "type error: Add"
eval (IsZero e)    = case eval e of
                         RI n -> RB (n == 0)
                         _    -> error "type error: IsZero"
eval (If e1 e2 e3) = 
    case eval e1 of
        RB b -> case (eval e2, eval e3) of
                    (RI n2, RI n3) -> RI $ if b then n2 else n3
                    (RB b2, RB b3) -> RB $ if b then b2 else b3
                    _              -> error "type error: If branches"
        _    -> error "type error: If condition"
\end{lstlisting}

\newpage

\subsection{Type-checking}

\imp{\emph{Nota}}. \texttt{.::} denota la composici贸n de tipos, y el \texttt{infix} el orden de precedencia del operador.

Podr铆a \imp{desacoplar} el type-checking de la evaluaci贸n
\begin{lstlisting}
data EType = TInt | TBool

infix 6 .::

(.::) :: Expr -> EType -> Bool
(Val n)      .:: TInt  = True
(Add e1 e2)  .:: TInt  = e1 .:: TInt && e2 .:: TInt
(IsZero e)   .:: TBool = e .:: TInt
(If c e1 e2) .:: t     = c .:: TBool && e1 .:: t && e2 .:: t
_            .:: _     = False

wellTyped :: Expr -> Bool
wellTyped e = e .:: TInt || e .:: TBool
\end{lstlisting}

y s贸lo evaluar en caso de tipar correctamente

\begin{lstlisting}
safeEval :: Expr -> Res
safeEval e | wellTyped e = eval e
           | otherwise   = error "type error"
\end{lstlisting}

\subsection{Tagless - Deep Embedding (Initial)}

Podemos usar el enfoque \imp{tagless} para que el sistema de tipos del lenguaje anfitri贸n realice el type-checking
\begin{lstlisting}
class ExprT (e :: * -> *) where
    valT    :: Int -> e Int
    addT    :: e Int -> e Int -> e Int
    isZeroT :: e Int -> e Bool
    ifT     :: e Bool -> e t -> e t -> e t
\end{lstlisting}

Necesito empaquetar Expr en un \texttt{* -> *} con un \imp{phantom type}

\begin{lstlisting}
newtype WExpr a = E Expr

instance ExprT WExpr where
    valT n                  = E (Val n)
    addT (E e1) (E e2)      = E (Add e1 e2)
    isZeroT (E e)           = E (IsZero e)
    ifT (E c) (E e1) (E e2) = E (If c e1 e2)
\end{lstlisting}

\subsection{Int茅rpretes Tipados}

Puedo definir un observador como pretty-printing sin problemas

\begin{lstlisting}
ppExpr (E (Val n)) = show n
ppExpr (E (Add e1 e2)) = "(" ++ ppExpr (E e1) ++ "+"
                             ++ ppExpr (E e2) ++ ")"
ppExpr (E (IsZero e)) = "isZero(" ++ ppExpr (E e) ++ ")"
ppExpr (E (If c e1 e2)) = "if " ++ ppExpr (E c) ++ 
                          " then " ++ ppExpr (E e1) ++ 
                          " else " ++ ppExpr (E e2)
\end{lstlisting}

Pero no puedo definir algo como

\begin{lstlisting}
evalExpr (E (Val n))      = n
evalExpr (E (IsZero e))   = evalExpr (E e) == 0
evalExpr (E (Add e1 e2))  = evalExpr (E e1) + evalExpr (E e2)
evalExpr (E (If c e1 e2)) = if evalExpr (E c)
                            then evalExpr (E e1)
                            else evalExpr (E e2)
                            
Couldn't match expected type 'Int' with actual type 'Bool'
In the expression: evalExpr (E e) == 0
...
\end{lstlisting}

Tampoco puedo definir

\begin{lstlisting}
evalExpr :: WExpr t -> t
evalExpr (E (Val n))      = n
evalExpr (E (IsZero e))   = evalExpr (E e) == 0
evalExpr (E (Add e1 e2))  = evalExpr (E e1) + evalExpr (E e2)
evalExpr (E (If c e1 e2)) = if evalExpr (E c)
                            then evalExpr (E e1)
                            else evalExpr (E e2)
                            
Couldn't match expected type 't' with actual type 'Int'
't' is a rigid type variable bound by
  the type signature for:
    evalExpr :: forall t. WExpr t -> t
...
In the expression: n
  In an equation for 'evalExpr': evalExpr (E (Val n)) = n
...
\end{lstlisting}

Se puede definir un workaround usando type-clases

\begin{lstlisting}
class Eval t where
    weval :: WExpr t -> t

instance Eval Int where
    weval (E (Val n))      = n
    weval (E (Add e1 e2))  = weval (E e1) + weval (E e2)
    weval (E (If c e1 e2)) = if weval (E c) 
                             then weval (E e1) 
                             else weval (E e2)

instance Eval Bool where
    weval (E (IsZero e))   = (weval (E e) :: Int) == 0
    weval (E (If c e1 e2)) = if weval (E c) 
                             then weval (E e1)
                             else weval (E e2)
\end{lstlisting}

\section{Tipos de Datos Algebr谩icos Generalizados (GADTs)}

\subsection{Tipo de Dato Algebr谩ico}

\begin{lstlisting}
data Tree a = Leaf a
            | Node (Tree a) (Tree a)
\end{lstlisting}

o alternativamente,
\begin{lstlisting}
data Tree :: * -> * where
    Leaf :: Tree a
    Node :: Tree a -> a -> Tree a -> Tree a
\end{lstlisting}
introduce:
\begin{itemize}
\item Un nuevo tipo de datos \imp{Tree} de kind \texttt{* -> *}
\item Constructores \imp{Leaf} y \imp{Node}
\item La posibilidad de usar los constructores en patterns 
\end{itemize}

\subsubsection{Restricciones}

Los constructores de un tipo de datos \imp{T} deben:

\begin{itemize}
\item Resultar en el tipo \imp{T}
\item Resultar en un tipo simple: \texttt{\imp{T} a1 ... an} con \texttt{a1 , ..., an} variables de tipo distintas
\end{itemize}

Vamos a levantar alguna de estas restricciones.

\subsection{Deep Embedding Untyped}

\begin{lstlisting}
data Expr :: * where
    Val    :: Int -> Expr
    Add    :: Expr -> Expr -> Expr
    IsZero :: Expr -> Expr
    If     :: Expr -> Expr -> Expr -> Expr
\end{lstlisting}

Por ejemplo, podemos escribir:

\begin{lstlisting}
If (IsZero (Add (Int 0) (Int 1))) (Val 3) (Val 4)
\end{lstlisting}

que representa la sintaxis abstracta de la siguiente expresi贸n escrita
en una sintaxis concreta:

\begin{lstlisting}
if isZero (0 + 1) then 3 else 4
\end{lstlisting}
Pero podemos escribir tambi茅n t茅rmimos \imp{mal tipados} de acuerdo al
sistema de tipos del EDSL.

\subsection{Deep Embedding Tipado}

La idea es codificar el tipo del t茅rmino que se representa en el propio tipo Haskell.

\begin{lstlisting}
data Expr :: * where
    Val    :: Int -> Expr
    Add    :: Expr -> Expr -> Expr
    IsZero :: Expr -> Expr
    If     :: Expr -> Expr -> Expr -> Expr
    
data Expr :: * -> * where
    Val    :: Int -> Expr Int
    Add    :: Expr Int -> Expr Int -> Expr Int
    IsZero :: Expr Int -> Expr Bool
    If     :: Expr Bool -> Expr t -> Expr t -> Expr t
\end{lstlisting}

\subsection{GADTs}

Los GADTs levantan la restricci贸n de que los constructores deben resultar en un tipo simple.

\begin{itemize}
\item Los constructores pueden resultar en un subconjunto del tipo
\item Consecuencias interesantes en el pattern matching
\begin{itemize}
\item cuando se analiza un \imp{Expr Int}, este no puede ser construido por \imp{IsZero}
\item cuando se analiza un \imp{Expr Bool}, este no puede ser construido
por \imp{Val} o \imp{Add}
\item cuando se analiza un \imp{Expr Bool}, si encontramos \imp{IsZero} en el
pattern, sabemos que tenemos un \imp{Expr Bool}
\item etc
\end{itemize}
\end{itemize}

\subsection{Evaluaci贸n usando GADTs: evaluador tagless}

\begin{lstlisting}
eval :: Expr t -> t
eval (Val n)      = n
eval (Add e1 e2)  = eval e1 + eval e2
eval (IsZero e)   = eval e == 0
eval (If c e1 e2) = if eval c then eval e1 else eval e2
\end{lstlisting}

\begin{itemize}
\item No hay posibilidad de fallos en tiempo de ejecuci贸n (salvo $\bot$)
\item No se requieren tags
\item El pattern matching sobre un GADT requiere signatura de tipo
\end{itemize}

\subsubsection{GADTs incluyen existenciales}

Si extendemos el lenguaje con la construcci贸n y proyecci贸n de
pares:

\begin{lstlisting}
data Expr :: * -> * where
    Val    :: Int -> Expr Int
    Add    :: Expr Int -> Expr Int -> Expr Int
    IsZero :: Expr Int -> Expr Bool
    If     :: Expr Bool -> Expr t -> Expr t -> Expr t
    Pair   :: Expr a -> Expr b -> Expr (a, b)
    Fst    :: Expr (a, b) -> Expr a
    Snd    :: Expr (a, b) -> Expr b
\end{lstlisting}

Para \imp{Fst} y \imp{Snd} se esconde el tipo del componente no proyectado.
Es como tener un tipo existencial:

\begin{lstlisting}
data Expr a = ... |  b.Fst (Expr (a, b))
\end{lstlisting}

\subsection{Ejemplo: vectores}

Un vector es una lista con largo:

\begin{lstlisting}
data Vec a n where
    Nil  :: Vec a Zero
    Cons :: a -> Vec a n -> Vec a (Succ n)
\end{lstlisting}
Los n煤meros naturales los vamos a codificar como tipos vac铆os:
\begin{lstlisting}
data Zero
data Succ a
\end{lstlisting}
De esta forma, en el tipo del vector tenemos codificado su largo:
\begin{lstlisting}
Nil                 :: Vec Int Zero
Cons 3 Nil          :: Vec Int (Succ Zero)
Cons 2 (Cons 3 Nil) :: Vec Int (Succ (Succ Zero))
\end{lstlisting}

\subsubsection{\texttt{head} y \texttt{tail}}

Las definiciones de head y tail son ahora seguras:

\begin{lstlisting}
head :: Vec a (Succ n) -> a
head (Cons x xs) = x

tail :: Vec a (Succ n) -> Vec a n
tail (Cons x xs) = xs
\end{lstlisting}

El caso Nil es exclu铆do porque no satisface el requerimiento de que la lista de entrada tenga largo mayor que cero. Por lo tanto, las expresiones:

\begin{lstlisting}
head Nil
tail Nil
\end{lstlisting}

resultan en un error de tipo.

\subsubsection{Funciones sobre vectores}

\begin{lstlisting}
map :: (a -> b) -> Vec a n -> Vec b n
map f Nil         = Nil
map f (Cons x xs) = Cons (f x) (map f xs)

zipWith :: (a -> b -> c) -> Vec a n -> Vec b n -> Vec c n
zipWith f Nil         Ni          = Nil
zipWith f (Cons x xs) (Cons y ys) = Cons (f x y ) (zipWith f xs ys)
\end{lstlisting}
La funci贸n zipWith requiere que los vectores tengan el mismo largo

\begin{lstlisting}
snoc :: Vec a n -> a -> Vec a (Succ n)
snoc Nil         y = Cons y Nil
snoc (Cons x xs) y = Cons x (snoc xs y )

reverse :: Vec a n -> Vec a n
reverse Nil         = Nil
reverse (Cons x xs) = snoc (reverse xs) x
\end{lstlisting}

\subsubsection{Concatenaci贸n de vectores}

\begin{lstlisting}
(++) :: Vec a m -> Vec a n -> Vec a (m  n)
\end{lstlisting}
Podemos calcular m $\oplus$ n de la siguiente manera:
\begin{itemize}
\item construir \imp{evidencia expl铆cita}
\item utilizar una \imp{type family} (funci贸n a nivel de tipos)
\end{itemize}

\subsection{Evidencia expl铆cita}

Codificar la suma como otro GADT:

\begin{lstlisting}
data Sum m n s where
    SumZero :: Sum Zero n n
    SumSucc :: Sum m n s -> Sum (Succ m) n (Succ s)

appV :: Sum m n s -> Vec a m -> Vec a n -> Vec a s
appV SumZero     Nil         ys = ys
appV (SumSucc p) (Cons x xs) ys = Cons x (appV p xs ys)
\end{lstlisting}
Desventaja: tenemos que construir la evidencia a mano

\subsection{Type Family}

\begin{lstlisting}
type family (m :: *) :+: (n :: *) :: * 
type instance Zero     :+: n = n
type instance (Succ m) :+: n = Succ (m :+: n)

(++) :: Vec a m -> Vec a n -> Vec a (m :+: n)
Nil       ++ ys = ys
Cons x xs ++ ys = Cons x (xs ++ ys)
\end{lstlisting}

\subsubsection{Convertir entre listas y vectores}

Sin problemas se puede hacer:
\begin{lstlisting}
toList :: Vec a n -> [a]
toList Nil         = []
toList (Cons x xs) = x : toList xs
\end{lstlisting}
Pero esto no funciona:
\begin{lstlisting}
fromList :: [a] -> Vec a n
fromList []     = Nil
fromList (x:xs) = Cons x (fromList xs)
\end{lstlisting}
El tipo dice que el resultado tiene que ser polim贸rfico en n, pero no lo es. Para lograrlo se puede

\begin{itemize}
\item Especificar el largo

Los n煤meros naturales al nivel de los tipos los reflejamos al nivel de los valores usando un tipo singleton.
\begin{lstlisting}
data SNat n where
    Zero :: SNat Zero
    Succ :: SNat n -> SNat (Succ n)
\end{lstlisting}
\imp{\texttt{SNat n}} tiene solo un valor por cada \texttt{n}:
\begin{lstlisting}
Zero             :: SNat Zero
Succ Zero        :: SNat (Succ Zero)
Succ (Succ Zero) :: SNat (Succ (Succ Zero))
\end{lstlisting}
Conociendo el largo de antemano:
\begin{lstlisting}
fromList :: SNat n -> [a] -> Vec a n
fromList Zero []         = Nil
fromList (Succ n) (x:xs) = Cons x (fromList n xs)
fromList _        _      = error "wrong length!"
\end{lstlisting}
\item Esconder el largo usando un tipo existencial

\begin{lstlisting}
data VecAny a where
    VecAny :: Vec a n -> VecAny a

fromList :: [a] -> VecAny a
fromList []     = VecAny Nil
fromList (x:xs) = case fromList xs of
                      VecAny ys -> VecAny (Cons x ys)
\end{lstlisting}
Tambi茅n podemos combinar ambas ideas e incluir un \imp{SNat} en el
tipo:
\begin{lstlisting}
data VecAny a where
    VecAny :: SNat n -> Vec a n -> VecAny a
\end{lstlisting}
\end{itemize}

\subsection{Reflexi贸n de tipos}

Mediante el uso de un GADT que refleje (represente) tipos:
\begin{lstlisting}
data Type t where
    RInt  :: Type Int
    RChar :: Type Char
    RList :: Type a -> Type [a]
    RPair :: Type a -> Type b -> Type (a, b)

\end{lstlisting}
es posible escribir \imp{funciones gen茅ricas} (\imp{type-indexed functions}) de
tipo
\begin{lstlisting}
f :: Type a -> ... a ...
\end{lstlisting}
que hagan recursi贸n en la representaci贸n de los tipos.

\subsubsection{Ejemplo: funci贸n de compresi贸n}

Queremos comprimir valores de tipos representados en Type.
\begin{lstlisting}
data Bit = 0 | 1

compress :: Type t -> t -> [Bit]
compress (RInt) i            = compressInt i
compress (RChar) c           = compressChar c
compress (RList ra) []       = 0 : []
compress (RList ra) (a : as) = 1 : compress ra a ++ 
                                   compress (RList ra) as
compress (RPair ra rb) (a, b) = compress ra a ++ compress rb b
\end{lstlisting}
\indent \indent donde
\begin{lstlisting}
compressInt :: Int -> [Bit]
compressChar :: Char -> [Bit]
\end{lstlisting}

son compresores para valores de \imp{Int} y \imp{Char}.

\end{document}