
% ******** Meta ******** %

\documentclass{article}
\usepackage[paper=a4paper, 
		    left=2cm, 
			right=2cm, 
			bottom=2.5cm, 
			top=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[colorlinks = true, linkcolor=color1]{hyperref}

% ******** Font ******** %

\usepackage[T1]{fontenc}
\usepackage{lmodern}\fontfamily{cmtt}
\usepackage{dirtytalk}

% ******** Color ******** %

\usepackage{xcolor}
\definecolor{color1}{RGB}{220,55,130}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% ******** Envs ******** %

\newcommand{\imp}[1]{\textcolor{color1}{#1}}

\usepackage{enumitem}
\setlist[itemize]{label=\textcolor{color1}{\tiny $\blacksquare$}}
\renewcommand{\labelenumi}{\textcolor{color1}{\arabic{enumi}.}}
\renewcommand{\labelenumii}{\textcolor{color1}{\arabic{enumi}.\arabic{enumii}}}
\renewcommand{\labelenumiii}{\textcolor{color1}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}}

\usepackage{listings}

\usepackage{listings}
\lstdefinestyle{mystyle}{
    commentstyle=\color{codegray},
    keywordstyle=\color{color1},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{color1},
    basicstyle=\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=4pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,     
    tabsize=2,
	frame=leftline, 
	framexleftmargin=5mm,
	frame=shadowbox,
	rulesepcolor=\color{color1},
	captionpos=t,
	xleftmargin=.05\textwidth,
	xrightmargin=.02\textwidth
}

\lstset{style=mystyle}

\lstset{
    language=Haskell,
    literate=
    {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
    {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
    {ñ}{{\~n}}1 {𐃏}{{$\oplus$}}1
}


% ******** Math ******** %

\usepackage{amsmath}
\usepackage{amssymb}

% ******** Doc Format ******** %

\addto\captionsspanish{
	\renewcommand{\contentsname}{Contenidos}
}

% ******** Headers ******** %

\usepackage{fancyhdr}\setlength{\headheight}{15.5pt}
\pagestyle{fancy}

\fancyheadinit{\color{color1}}
\fancyfootinit{\color{color1}}
\fancyhead[C,R]{}
\fancyhead[L]{\leftmark}
\fancyfoot[L,C]{}
\fancyfoot[R]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}


% ******** Body ******** %

\title{\Huge Abordaje funcional a EDSLs}
\author{Lucas Di Salvo}
\date{ECI 37 - 2024}

\begin{document}

\maketitle

\tableofcontents

\thispagestyle{empty}

\newpage

\section{Introducción}\label{sec:introduccion}

Un lenguaje de dominio específico (DSL) es un lenguaje de programación o especificación de expresividad limitada, especialmente diseñado para resolver problemas en un particular dominio. Por ejemplo
\begin{itemize}
\item HTML
\item VHDL (hardware)
\item Mathematica, Maple
\item SQL, XQuery (lenguajes de query)
\item Yacc y Lex (para generación de parser)
\item \LaTeX (para producir documentos)
\item DSLs para aplicaciones financieras (\url{http://www.dslfin.org})
\end{itemize}
Existen dos abordajes principales para implementar DSLs:

\begin{itemize}
\item \imp{Externo}: Lenguaje standalone donde es necesario desarrollar lexer, parser, compilador, y demás herramientas.
\item \imp{Interno}: Lenguaje implementado en el contexto de otro (embebido).
\end{itemize}

\subsection{DSLs embebidos}\label{subsec:dsls_embebidos}

Los \imp{Embedded DSLs} (EDSLs) son DSLs implementados como bibliotecas específicas en lenguajes de propósito general que actuan como anfitrión (host languages). De esta manera el EDSL puede hacer uso de la infraestructura y facilidades existentes en el lenguaje anfitrión.

\

La implementacion de un EDSL suele reducir el costo de desarrollo (se evita implementar lexer, parser, etc), y los lenguajes funcionales, en particular Haskell, son muy
apropiados para la implementación de EDSLs. Es relevante mencionar que el manejo de errores suele ser un punto debil de los EDSLs. Algunos ejemplos de EDSLs en Haskell son:

\begin{itemize}
\item Quickcheck
\item Sequence (finger trees)
\item Streams
\item HaXml (procesamiento de XML, HTML)
\item Lava (hardware description)
\item Parsec (parsing)
\item Pretty printing
\item Haskore (para componer música)
\end{itemize}

\newpage

\section{Tipos de EDSLs}\label{sec:tipos_de_edsls}
    
\noindent Los EDSLs se caracterizan por tener:

\begin{itemize}
\item Shallow embedding
\begin{itemize}
\item Se captura directamente en un tipo de dato la semántica de los datos del dominio.
\item Se elige un tipo concreto de manera explicita, cuya interpretación es fija.
\item Las operaciones del DSL manipulan directamente los valores del dominio.
\end{itemize}
\item Deep embedding
\begin{itemize}
\item Las construcciones del DSL son representadas como términos de tipos de datos que corresponden a árboles de sintaxis abstracta (AST).
\item Está más cerca de un lenguaje standanlone.
\item Los términos son luego recorridos para su evaluación
\item No hay una semántica fija, sino que se pueden definir diferentes interpretaciones.
\item Las operación dictan la semántica.
\end{itemize}
\end{itemize}

\subsection*{Ejemplo de EDSL}

Consideremos un lenguaje que manipula expresiones aritméticas formado por las siguientes operaciones:

\begin{lstlisting}
val :: Int -> Expr           -- Constuctor, 
                             -- todo entero es una expresión
add :: Expr -> Expr -> Expr  -- Constructor, 
                             -- la suma de expresiones es una expresión
eval :: Expr -> Int          -- Observador, evalua una expresión
\end{lstlisting}

Ejemplo de un programa en el DSL:

\begin{lstlisting}
siete :: Expr
siete = add (val 3) (val 4)

dovle :: Expr -> Expr
doble e = add e e

runDoble :: Expr -> Int
run Doble e = eval (doble e)
\end{lstlisting}

\section{Shallow Embedding}\label{sec:shallow_embedding}

\noindent Se captura directamente la semántica del dominio que manipula el DSL. Para este tipo de expresiones aritméticas, la representación por defecto es usar un entero, el cuál va a denotar el valor de la expresión.

\

\begin{lstlisting}
type Expr = Int
-- Constructores
val n    = n
add e e' = e + e'
-- Observador
eval e = e
\end{lstlisting}

\section{Deep Embedding}\label{sec:deep_embedding}

\noindent Se definen las formas de construir expresiones a través de un tipo

\begin{lstlisting}
data Expr where
  Val :: Int -> expr
  Add :: Expr -> Expr -> Expr
\end{lstlisting}
Operaciones de construcción (smart constructors, se usan para ocultar la implementación
interna):
\begin{lstlisting}
val :: Int -> Expr
val n = Val n
  
add :: Expr -> Expr -> Expr
add e e' = Add e e'
\end{lstlisting}
El observador ahora hace las veces de función de interpretación
\begin{lstlisting}
eval :: Expr -> Int
eval (Val n)    = n
eval (Add e e') = eval e + eval e'
\end{lstlisting}


\section{¿Qué embedding elegir? (expression problem)}\label{sec:expression_problem}


\begin{itemize}
\item[] \imp{Shallow embedding}
\begin{itemize}
\item[] \imp{Pros}: Es simple agregar nuevas construcciones al EDSL (por ejemplo, mult), mientras se puedan representar en el dominio de interpretación
\item[] \imp{Cons}: Agregar nuevas formas de interpretación (por ejemplo, hacer un pretty printing de las expresiones) puede implicar una reimplementación completa. Adicionalmente, los constructores ya evaluan.
\end{itemize}
\item[] \imp{Deep embedding}
\begin{itemize}
\item[] \imp{Pros}: Es simple agregar un nuevo observador (por ejemplo, pretty printing).
\item[] \imp{Cons}: Agregar nuevas construcciones al lenguaje (como mult) implica modificar el tipo del AST (el tipo \texttt{Expr})  reimplementar todos los observadores (las funciones de interpretación).
\end{itemize}
\end{itemize}

\section{Razonamiento sobre EDSLs}\label{sec:razonamiento_sobre_edsls}

\noindent A partir de la definición del EDSL en Haskell (tanto como shallow o deep embedding) es posible probar propiedades del EDSL. Por ejemplo:
\begin{center}
\texttt{add e (add e' e'') = add (add e e') e''} \\
\texttt{add e e' = add e' e}
\end{center}

\newpage

\section{Tipos Algebráicos}\label{sec:tipos_algebraicos}

\begin{lstlisting}
-- Notación de Generalized Algebraic Data Types (GADTs):
data Expr where
  Val :: Int -> Expr
  Add :: Expr -> Expr -> Expr
    
-- Notación clásica
data Expr = Val Int | Add Expr Expr
\end{lstlisting}

En general:
\begin{lstlisting}
data T a_1 ... a_m = C_1 t_11 ... t_1k_1
                     ...
                   | C_n t_n1 ... t_nk_n
\end{lstlisting}                   

Donde las variables \texttt{a\_i} puede ser usadas en la definición de los constructores. Y se tiene una manera simple de definir estructuras arborescentes:

\begin{lstlisting}
data Tree a = Leaf a | Fork (Tree a) (Tree a)

data Tree a where
  Leaf :: a -> Tree a
  Fork :: Tree a -> Tree a -> Tree a
\end{lstlisting}

Los términos de un lenguaje son estructuras arborescentes.

\subsection{Constructores}\label{subsec:gadts_constructores}

\begin{lstlisting}
-- Los constructores se introducen al definir el tipo.
data Expr where
  Val :: Int -> Expr
  Add :: Expr -> Expr -> Expr
-- También puede definir "smart" constructors
val = Val
add = Add
  
val x | x >= 0 = val x
\end{lstlisting}
\subsection{Observadores}\label{subsec:gadts_observadores}

\begin{lstlisting}
-- Dado el tipo:
data Expr where
  Val :: INt -> Expr
  Add :: Expr -> Expr -> Expr    
-- Puedo definir observadores (funciones) por casos, 
-- usando patter-matching y recursión
eval :: Expr -> Int
eval (Val x)   = x
eval (Add x y) = eval x + eval y
\end{lstlisting}

Los patrones satisfacen la gramática:

\[pat~::= ~\_ ~|~variable~|~literal~|~(pat_1, \ldots, pat_m)~|~pat:pat~|~C~pat_1~\ldots~pat_n~|~var@pat\]
          
\section{Observadores - Alto Orden}\label{sec:observadores_alto_orden}

\noindent Multiples observadores puede compartir un patrón de recursión:
\begin{lstlisting}
eval :: Expr -> Int
eval (Val x)   = x
eval (Add x y) = eval x + eval y

cantVals :: Expr -> Int
cantVals (Val _)   = 1
cantVals (Add x y) = cantVals x + cantVals y

ppExpr :: Expr -> String
ppExpr (Val x)   = show x
ppExpr (Add x y) = ppExpr x ++ " + " ++ ppExpr y

\end{lstlisting}

Puedo defirnir funciones de alto orden para capturar ese patrón
\begin{lstlisting}
foldExpr :: (Int -> a) -> (a -> a -> a) -> Expr -> a
foldExpr fv _  (Val x)   = fv x
foldExpr fv fa (Add x y) = fa (rec x) (rec y)
  where rec = foldExpr fv fa
-- Luego se puede definir:
eval     = foldExpr id (+)
cantVals = foldExpr (const 1) (+)
ppExpr   = foldExpr show (\ppx ppy -> ppx ++ " + " ++ ppy)
\end{lstlisting}

\subsection{Alto Orden en Shallow Embedding}\label{subsec:alto_orden_shallow_embedding}

Agregamos variables a nuestro lenguaje de expresiones:

\begin{lstlisting}
val :: Int -> Expr
add :: Expr -> Expr -> Expr
var :: String -> Expr
\end{lstlisting}  

Nuestro evaluador debería poder aplicar el ambiente de variables:

\begin{lstlisting}
eval :: Expr -> [(String, Int)] -> Int
\end{lstlisting}

Entonces el tipo Expr es:

\begin{lstlisting}
type Expr = [(String, Int)] -> Int
\end{lstlisting}

y los constructores son funciones de alto orden

\begin{lstlisting}
val x   = \_   -> x
add x y = \env -> x env + y env
var v   = \env -> slookup v env  -- función placeholder para lookup
\end{lstlisting}

\newpage

\section{Type classes}\label{sec:type_classes}

\noindent Podemos empaquetar la API del lenguaje en una type class:
\begin{lstlisting}
class IExpr e where
  val  :: Int -> e
  add  :: e -> e -> e
  eval :: e -> Int
\end{lstlisting}

Definiendo instancias para cada implementación:

\begin{lstlisting}
data Expr = Val Int | Add Expr Expr

instance IExpr Expr where
  val = Val
  add = Add
  eval = foldExpr id (+)
    
instance IExpr Int where
  val n  = n
  add x  = x + y
  eval e = e
\end{lstlisting}

\section{Ejeplo - Regiones geométricas}\label{sec:ejemplo_regiones_geometricas}

\noindent Consideremos un lenguaje que manipula regiones geómetricas formado por las siguientes operaciones:

\begin{lstlisting}
class Region r where
  inRegion   :: Point -> r -> Bool --observador
  circle     :: Radius -> r
  outside    :: r -> r
  union      :: r -> r -> r
  interesect :: r -> r -> r
\end{lstlisting}

Ejemplo de un program en el DSL

\begin{lstlisting}
aro :: Region r => Radius -> Radius -> r
aro r1 r2 = outside (circle r1) `intersect` circle r2
\end{lstlisting}
  
\subsection{Shallow embedding}

Se captura directamente la semántica del dominio que manipula el DSL, en este caso regiones.

\

Una región geometrica se va a representar por la función característica del conjunto de puntos (dice que puntos están y cuales no)

\begin{lstlisting}
data SRegion = R (Point -> Bool)
-- y la instancia
instance Region SRegion where
  p `inRegion` (R r)       = r p
  circle r                 = R $ \p -> magnitude p =< r
  outside (R r)            = R $ \p -> not (r p)
  (R r) `union` (R r')     = R $ \p -> r p || r' p
  (R r) `intersect` (R r') = R $ \p -> r p && r' p
\end{lstlisting}

\subsection{Deep embedding}

Se definen las formas de construir regiones a través de un tipo

\begin{lstlisting}
data DRegion = Circle Radius
             | Outside DRegion
             | Union DRegion DRegion
             | Intersect DRegion DRegion
-- y la instancia
instance Region DRegion where
  circle r         = Circle r
  outside r        = Outside r
  r `union` r'     = Union r r'
  r `intersect` r' = Intersect r r'
  p `inRegion` (Circle r)       = magnitude p <= r
  p `inRegion` (Outside r)      = not (p `inRegion` r)
  p `inRegion` (Union r r')     = p `inRegion` r || p `inRegion` r'
  p `inRegion` (Intersect r r') = p `inRegion` r && p `inRegion` r'
\end{lstlisting}

donde la implementación del esquema de recursión estructural para \texttt{DRegion} es

\begin{lstlisting}
foldRegion :: Region r => (Radius -> a) -> (a -> a) -> (a -> a -> a) 
                                        -> (a -> a -> a) -> r -> a
foldRegion fCir fOut fUni fInt reg = case reg of
    Circle rad          -> fCir $ rec rad
    Outside reg'        -> fOut $ rec reg'
    Union reg1 reg2     -> fUni (rec reg1) (rec reg2)
    Intersect reg1 reg2 -> fInt (rec reg1) (rec reg2)
  where
    rec = foldRegion fCir fOut fUn fInt
\end{lstlisting}

\section{Parser aplicativos}\label{sec:parser_aplicativos}

\subsection{Combinadores de parsing}\label{subsec:sombinadores_de_parsing}

Los combinadores de parsing forman un EDSL que es implementado usando un shallow embedding. Están formados por dos grupos de funciones:

\begin{itemize}
\item Funciones básicas que sirven para reconocer determinados strings de entrada.
\item Un grupo de combinadores que permiten construir nuevos parsers a partir de otros.
\end{itemize}

\imp{\emph{Comentario}}: Los parsers no son totales.

\subsubsection{Parser elementales}

La mayoría de las bibliotecas de parsing están formadas por los siguientes 4 combinadores básicos, que se usaran para distintos elementos de la gramática.:

\begin{itemize}
\item String vacío \texttt{pSuceed}, para la cadena vacía.
\item Terminales \texttt{pSym s}, para literales terminales
\item Alternativa \texttt{p$_1$ <|>~p$_2$}, para optar por un parser u otro
\item Composición \texttt{p$_1$ <*>~p$_2$}, para composición de parsers.
\end{itemize}

\subsubsection{El tipo de un parser}

Un parser puede ser entendido como una función que toma un string de entrada y retorna algo de tipo \imp{\texttt{a}}:

\begin{lstlisting}
String -> a
\end{lstlisting}

Un parser podría ser ambiguo (si la gramática es ambigua, el parser lo será) y retornar varios posibles valores, significando que puede haber varias formas de reconocer la entrada. En este caso la lista vacía podría tomarse como una falla.

\begin{lstlisting}
String -> [a]
\end{lstlisting}

A su vez, un parser podría no consumir toda la entrada y retornar además la parte de la entrada no consumida, para asociar el resultado del cómputo de cada parser a cada cadena (ya que el parser puede bien no ser determinista).

\begin{lstlisting}
String -> [(a, String)]
\end{lstlisting}

En resumen, 

\begin{lstlisting}
type Parser a = String -> [(a, String)]
\end{lstlisting}

y podemos abstraer el tipo \imp{\texttt{String}} de forma:

\begin{lstlisting}
type Parser s a = Eq s => [s] -> [(a, [s])]
\end{lstlisting}

\emph{i.e.} en su lugar ponemos ua lista de valores de tipo \imp{\texttt{s}}, donde a los mismos les vamos a requerir que sean comparables por igualdad (instancia de la clase \imp{\texttt{Eq}})

\subsubsection{Combinadores básicos}

\begin{lstlisting}
pFail    ::                                    Parser s a
pSucceed :: a                               -> parser s a
pSym     :: Eq s => s                       -> Parser s s
<|>      :: Parser s a        -> Parser s a -> Parser s a
<*>      :: Parser s (a -> b) -> Parser s a -> Parser s b
\end{lstlisting}

Para cada uno de ellos escribo su definición

\begin{lstlisting}
pFail :: Parser s a                                      -- Falla
pFail = \_ -> []

pSucceded :: a -> Parser s a                             -- Éxito
pSucceed a = \cs -> [(a, cs)]

pSym :: Eq s => s -> Parser s s                          -- Símbolo
pSym s = \cs -> case cs of
    []      -> []
    (c:cs') -> if c == s
               then [(c, cs')]  -- encontró el símbolo
               else []          -- falla

(<|>) :: Parser s a -> Parser s a -> Parser s a          -- Alternativa
p <|> q = \cs -> p cs ++ q cs

(<*>) :: Parser s (a -> b) -> Parser s a -> Parser s b   -- Composición
(p <*> q) = \cs -> [(f a, cs'') | (f, cs')  <- p cs
                                , (a, cs'') <- q cs']
\end{lstlisting}

\subsubsection{Ejemplos de parsers}

\begin{itemize}
\item Reconocer una \texttt{'A'} y retornar una \texttt{'B'}:
\begin{lstlisting}
pA2B = pSucceed (\_ -> 'B') <*> pSym 'A'
\end{lstlisting}
\item Reconocer una \texttt{'A'}, seguida de una \texttt{'B'}, y retornar ambos caracteres en un par:
\begin{lstlisting}
pAB = pSucceed (,) <*> pSym 'A' <*> pSym 'B'
\end{lstlisting}
\item Parser que retorna una \emph{lista} de valores de tipo \texttt{a}. Toma como parámetro un parser que retorna un \texttt{a}.
\begin{lstlisting}
pList :: Parser s a -> Parser s [a]
pList p = pSucceed (:) <*> p <*> pList p
          <|>
          pSucceed []
\end{lstlisting}
\item Parser que reconoce u nstring de la forma \texttt{(AB)*}
\begin{lstlisting}
pListAB = pList pAB
\end{lstlisting}
\end{itemize}

\subsubsection{Otros combinadores útiles}

\begin{lstlisting}
(<$>) :: (a -> b) -> Parser s a -> Parser s b
f <$> p = pSucceed f <*> p

opt :: Parser s a -> a -> Parser s a
p `opt` a = p <|> pSucceed a

pSat :: (s -> Bool) -> Parser s a
pSat p = \cs -> case cs of
                    []      -> []
                    (c:cs') -> if p c
                               then [(c, cs')] 
                               else []
\end{lstlisting}

\begin{itemize}
\item Definición de \imp{pAB} usando \texttt{<\$>}

\begin{lstlisting}
pAB = (,) <$> pSym 'A' <*> 'B'
\end{lstlisting}
\item Definición de \imp{Psym} usando \imp{pSat}

\begin{lstlisting}
pSym a = pSat (== a)
\end{lstlisting}
\item Reconocer un dígito

\begin{lstlisting}
pDigit = pSat isDigit
  where isDigit c = (c >= '0') && (c <= '9')
\end{lstlisting}
\item Definición de \imp{pList} usando \texttt{<\$>} y \imp{opt}

\begin{lstlisting}
pList p = (:) <$> p <*> pList p `opt` []
\end{lstlisting}
\end{itemize}

\subsubsection{Selección de resultados de parser}

\begin{lstlisting}
(<*) :: Parser s a -> Parser s b -> Parser s a
p <* q = (\x _ -> x) <$> p <*> q

(*>) :: Parser s a -> Parser s b -> Parser s b
p *> q = (\_ y -> y) <$> p <*> q

(<$) :: a -> Parser s b -> Parser s a
a <$ q = pSucceed a <* q
\end{lstlisting}

Ejemplo, reconocer algo entre paréntesis
\begin{lstlisting}
pParens p = pSym '(' *> p <* pSym ')'
\end{lstlisting}
\section{Functor}\label{sec:functor}

\noindent Un \imp{functor} puede entenderse como un constructor de tipo \texttt{f :: * $\rightarrow$ *} junto a una función de tipo 
\[(a  \rightarrow b) \rightarrow f~a \rightarrow f~b\]
que permite mapear/reemplazar los valores de tipo \imp{\texttt{a}} contenidos en una estructura de tipo \imp{\texttt{f a}} por valores de tipo \imp{\texttt{b}}. En Haskell el concepto de functor es capturado por una clase:


\begin{lstlisting}
class Functor (f :: * -> *) where
    fmap :: (a -> b) -> f a -> f b
\end{lstlisting}

Para ser efectivamente un functor la función fmap debe satisfacer las siguientes propiedades:

\begin{lstlisting}
fmap id    = id
fmap (f.g) = fmap f . fmap g
\end{lstlisting}
que deberían ser chequeadas al definir las instancias de la clase.

\subsection{Ejemplos}

\begin{lstlisting}
instance Functor [] where
    fmap = map

instance Functor Maybe where
    fmap f Nothing  = Nothing
    fmap f (Just a) = Just (f a)
    
    
instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x)  = Left x
    
instance Functor ((->) r) where
    fmap f h = \r -> f (h r)       -- o sea, f.h
\end{lstlisting}

\subsection{Modelando Error con Maybe}\label{subsec:modelando_error_con_maybe}

\begin{lstlisting}
divM x y | y /= 0    = Just (x `div` y)
         | otherwise = Nothing
\end{lstlisting}

Con fmap se puede aplicar una función pura al resultado de una división

\begin{lstlisting}
foo x y = fmap (+2) (divM x y)
\end{lstlisting}

en lugar de hacer:

\begin{lstlisting}
foo x y = case divM x y of
    Just r  -> Just (r+2)
    Nothing -> Nothing
\end{lstlisting}

\section{Functores Aplicativos}\label{sec:functores_aplicativos}

\noindent Los \imp{functores aplicativos} son functores que permiten modelar efectos al aplicar funciones dentro del functor (lo que les da el mote de aplicativos)

\begin{lstlisting}
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{lstlisting}

Se debe cumplir que:

\begin{lstlisting}
fmap f x = pure f <*> x
\end{lstlisting}

Sinónimo en \imp{Applicative}:

\begin{lstlisting}
(<$>) :: Functor f => (a -> b) -> f a -> f b
f <$> t = fmap f t
\end{lstlisting}

\subsection{Ejemplo: Maybe}

\begin{lstlisting}
instance Applicative Maybe where
    pure = Just
    (Just f) <*> (Just x) = Just (f x)
    -        <*> -        = Nothing
\end{lstlisting}

Puedo por ejemplo modelar expresiones con errores:

\begin{lstlisting}
type Expr = Maybe Int
valE x = pure x
addE x y = (+) <$> x <*> y
divE x y = case (x,y) of
               (Just vx, Just vy) -> divM vx vy
               _                  -> Nothing
\end{lstlisting}

\subsection{Leyes de functores aplicativos}

\begin{itemize}
\item Identidad:
\begin{center}
\texttt{pure id <*>~u $\equiv$ u}
\end{center}
\item Composición:
\begin{center}
\texttt{pure (.) <*>~u <*>~v <*>~w $\equiv$ u <*>~(v <*>~w)}
\end{center}
\item Homomorfismo:
\begin{center}
\texttt{pure f <*>~pure x $\equiv$ pure (f x)}
\end{center}
\item Intercambio:
\begin{center}
\texttt{u <*>~pure x $\equiv$ pure ($\backslash$f $\rightarrow$ f x) <*>~u}
\end{center}
\end{itemize}
Se cumple entonces
\begin{center}
\texttt{fmap~f~x = pure~f <*> x}
\end{center}

\section{Funciones sobre functores aplicativos}\label{sec:funciones_sobre_functores_aplicativos}

\begin{lstlisting}
sequenceA :: Applicative f => [f a] -> f [a]
sequenceA []     = pure []
sequenceA (a:as) = (:) <$> a <*> sequenceA as

traverse :: Applicative f => (a -> f b) -> [a] -> f [b]
traverse f = sequenceA . fmap f
\end{lstlisting}
    
donde esto último es equivalente a la siguiente definición
\begin{lstlisting}    
traverse f []     = pure []
traverse f (x:xs) = (:) <$> f x <*> traverse f xs
\end{lstlisting}

\section{Alternative}\label{sec:alternative}

\noindent En \imp{Control.Applicative} tambien se define:

\begin{lstlisting}
class Applicative f => Alternative f where
    empty :: f a
    (<|>) :: f a -> f a -> f a
    some  :: f a -> f [a]       -- one or more
    many  :: f a -> f [a]       -- zero or more
\end{lstlisting}

\subsection{Ejemplo de Alternative: Parsers}\label{subsec:ejemplo_de_alternative_parsers}

\begin{lstlisting}
instance Applicative (Parser s) where
    pure = pSucceed
    <*> = <*>

instance Alternative (Parser s) where
    empty = pFail
    <|>   = <|>
    many = pList
    some p = (:) <$> p <*> pList p
\end{lstlisting}

donde

\begin{lstlisting}
pFail :: Parser s a
pSuceed :: a -> Parser s a
<*> :: Parser s (a -> b) -> Parser s a -> Parser s b
<|> :: Parser s a -> Parser s a -> Parser s a
pList :: Parser s a -> Parser s [a]
\end{lstlisting}

\subsubsection{Ejemplo: Listas}

\begin{lstlisting}
instance Applicative [] where
    pure x    = [x]
    fs <*> xs = [f x | f <- fs, x <- xs ]
\end{lstlisting}

Ejemplo:
\begin{lstlisting}
[(+1), (+2)] <*> [1, 2, 3]
\end{lstlisting}
\indent \indent evalúa a
\begin{lstlisting}
[2, 3, 4, 3, 4, 5]
\end{lstlisting}

\subsubsection{Ejemplo: Either}

\begin{lstlisting}
data Either a b = Left a | Right b

instance Functor (Either e) where
fmap f (Right a) = Right (f a)
fmap f (Left e)  = Left e
\end{lstlisting}

Una posible instancia de Applicative:

\begin{lstlisting}
instance Applicative (Either e) where
    pure                = Right
    Right f <*> Right a = Right (f a)
    Right f <*> Left e  = Left e
    Left e  <*>         = Left e
\end{lstlisting}

Otra:

\begin{lstlisting}
instance Monoid e -> Applicative (Either e) where
    pure = Right
    Right f <*> Right a  = Right (f a)
    Left e  <*> Right    = Left e
    Right   <*> Left e   = Left e
    Left e  <*> Left e 0 = Left (e `mappend` e 0 )
\end{lstlisting}

\subsection{Composición}

La clase de los functores aplicativos es cerrada bajo la composición.

\begin{lstlisting}
newtype (f :. g) a = Compose {getCompose :: f (g a)}

instance (Functor f, Functor g) => FUnctor (f :. g) where
    fmap f (Compose x) = Compose (fmap (fmap f) x)
    
instance (Applicative f, Applicative g) => Applicative (f :. g) where
    pure x                  = Compose (pure (pure x))
    COmpose f <*> Compose x = Compose ((<*>) <$> f <*> x)
\end{lstlisting}

La composisición de dos mónadas puede no ser un mónada, pero sí es un aplicativo.

\newpage

\section{Evaluador con Fallas}

\begin{lstlisting}
eval :: Expr -> Maybe Int
eval (Val n)   = Just n
eval (Add x y) = case eval x of
                     Nothing -> Nothing
                     Just a  -> case eval y of
                                   Nothing -> NOthing
                                   Just b  -> Just (a + b)

eval (Div x y) = case eval x of
                     Nothing -> Nothing
                     Just a  -> case eval y of
                                   Nothing -> Nothing
                                   Just b  -> Just a `divM` b
\end{lstlisting}

\subsection{Evaluador con Fallas - Applicative}

\begin{lstlisting}
eval :: Expr -> Maybe Int
eval (Val n)   = pure n
eval (Add x y) = (+) <$> eval x <*> eval y
eval (Div x y) = case eval x of
                     Nothing -> Nothing
                     Just a  -> case eval y of
                         Nothing -> Nothing 
                         Just b -> a `divM` b`
\end{lstlisting}

No puedo representar la división con Functores Aplicativos, necesito el resultado de una computación para determinar el siguiente efecto.


\subsection{Capturemos patrones}

Primero definimos

\begin{lstlisting}
return :: a -> Maybe a
return a = Just a

(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
m >>= f = case m of
              Nothing -> Nothing
              Just a  -> f a
\end{lstlisting}

Entonces,

\begin{lstlisting}
eval :: Expr -> Mabe Int
eval (Val n)   = return n
eval (Add x y) = eval x >>= (\a -> eval y >>= (\b -> return (a+b)))
eval (Div x y) = eval x >>= (\a -> eval y >>= (\b -> a `dibM` b))
\end{lstlisting}

y escrito de manera similar

\begin{lstlisting}
eval :: Expr -> Mabe Int
eval (Val n)   = return n
eval (Add x y) = eval x >>= \a -> 
                 eval y >>= \b -> 
                 return (a+b)
eval (Div x y) = eval x >>= \a -> 
                 eval y >>= \b -> 
                 a `dibM` b
\end{lstlisting}

\section{La clase Monad}

\begin{lstlisting}
clasee Applicative m => Monad m ehere
(>>=)  :: m a -> (a -> m b) -> m b
(>>)   :: m a -> m b -> m b
return :: a -> m a

-- donde

m >> k = m >>= \_ -> k
\end{lstlisting}

Toda mónada es un functor aplicativo que cumple:

\begin{itemize}
\item[]

\begin{lstlisting}
pure = return
\end{lstlisting}

\item[]

\begin{lstlisting}
m1 <*> m2 = m1 >>= (\f -> m2 >>= (\x -> return (f x)))
\end{lstlisting}
\end{itemize}

No todo \imp{functor aplicativo} es una \imp{mónada}.

\subsection{Mónada Maybe}

\begin{lstlisting}
data Maybe a = Just a | Nothing

Instance Monad Maybe where
    return  = Just
    m >>= k = case m of
                  Just x  -> k x
                  Nothing -> Nothing 

instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just a) = Just (f a)
    
instance Applicative Maybe where
    pure                  = Just
    (Just f) <*> (Just x) = Just (f x)
    _        <*> _        = Nothing
    
-- Visto como mónada

instance Applicative Maybe where
    pure                  = return
    m1 <*> m2 = m1 >>= (\f -> m2 >>= (\x -> return (f x)))
\end{lstlisting}

\subsection{Leyes de mónadas}

\begin{itemize}
\item $return~x \gg = f = f~x$
\item $m \gg = return = m$
\item $(m \gg = f) \gg = g = m \gg = \backslash x \rightarrow (f~x \gg g)$
\end{itemize}

\subsection{Composición funciones monádicas}

Composición de Kleisli

\begin{lstlisting}
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
f >=> g = \a -> f a >>= g
\end{lstlisting}

Propiedades:

\begin{itemize}
\item $return >=> f = f$
\item $f >=> return = f$
\item $f >=> (g >=> h) = (f >=> g) >=> h$
\end{itemize}

\imp{\emph{Nota}}: Estas propiedades se pueden probar usando las leyes de mónadas.

\subsection{Notación do}


\begin{lstlisting}
do m = m
do {x <- m; m'} = m >>= \x -> do m'
do {m; m'}      = m >> do m'
\end{lstlisting}

\subsection{Evaluador con Fallas (notación do)}

\begin{lstlisting}
eval :: Expr -> Maybe Int
eval (Val n) = return n
eval (Add x y) = do a <- eval x
                    b <- eval y
                    return (a + b)
eval (Div x y) = do a <- eval x
                    b <- eval y
                    a `divM` b
\end{lstlisting}

\newpage

\subsection{Monada Either}

\begin{lstlisting}
data Either a b = Left a | Right b

instance Monad (Either e) where
    return        = Right
    Left e >>=  _ = Left e
    Right a >>= f = f a

-- Se corresponde con:

instance Applicative (Either e) where
    pure                = Right
    Right f <*> Right a = Right (f a)
    Right f <*> Left e  = Left e
    Left e <*>          = Left e

-- Pero no con:

instance Monoid e => Applicative (Either e) where
    pure                = Right
    Right f <*> Right a = Right (f a)
    Left e  <*> Right _ = Left e
    Right _ <*> Left e  = Left e
    Left e  <*> Left e' = Left (e `mappend` e')

\end{lstlisting}

\subsubsection{Applicative no monádico}

La instancia anterior de \imp{\texttt{Applicative}} para \imp{\texttt{Either}} \emph{no} es una mónada.

\begin{lstlisting}
instance Monoid e => Monad (Either e) where
    return       = Right
    Left e >>= f = ??
    ...
\end{lstlisting}

\begin{itemize}
\item No podemos aplicar f en este caso porque solo se aplica cuando la primera computación retorna un valor \imp{\texttt{Right} a}
\item Esto no ocurre en la instancia de \imp{\texttt{Applicative}}
\end{itemize}

\subsubsection{Diferencia entre functores aplicativos y mónadas}

La diferencia entre se puede apreciar en los siguientes operadores condicionales:

\begin{lstlisting}
ifM :: Monad m => m Bool -> m a -> m a -> m a
ifM mb mt me = do b <- mb
                  if b then mt else me
\end{lstlisting}
No todas computaciones se ejecutan (se elije entre mt y me), pero en este caso 
\begin{lstlisting}
ifA :: Applicative f => f Bool -> f a -> f a -> f a
ifA fb ft fe = cond <$> fb <*> ft <*> fe
  where
    cond b t e = if b then t else e
\end{lstlisting}

Las tres computaciones (fb, ft y fe) se ejecutan y finalmente se elije uno de los resultados.

\subsection{Mónada de estado}

\begin{lstlisting}
newtype State s a = State (s -> (a, s))

runState :: State s a -> (s -> (a, s))
runState (State f) = f

instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= f  = State $ \s -> let (a, s') = runState m s
                             in runState (f a) s'
\end{lstlisting}

Forma alternativa de escribir la definición de ($\gg=$):

\begin{lstlisting}
(State g) >>= f = State $ \s -> let (a, s') = g s
                                    State k = f a
                                in k s'
\end{lstlisting}

\subsubsection{Funciones sobre estado}

\begin{lstlisting}
get :: State s s
get = State $ \s -> (s, s)

put :: s -> State s ()
put s = State $ \_ -> ((), s)

modify :: (s -> s) -> State s ()
modify f = get >>= \s -> put (f s)

evalState :: State s a -> s -> a
evalState m s = fst $ runState m s

execState :: State s a -> s -> s
execState m s = snd $ runState m s
\end{lstlisting}

\subsubsection{Ejemplo: Contar número de sumas en una expresión}

\begin{lstlisting}
tick :: State Int ()
tick = modify (+1)

evalS :: Expr -> State Int Int
evalS (Val n)    = return n
evalS (Add e e') = do a <- evalS e
                        b <- evalS e'
                        tick
                        return (a + b)

nroSumas e = execState (evalS e) 0
\end{lstlisting}

\newpage

\subsection{Evaluador con variables}

\begin{lstlisting}
data Expr = Val Int
          | Add Expr Expr
          | Var ID         -- variables
          | Assign ID Expr -- asignación

eval :: Expr -> State (Map ID Int) Int
eval (Val n)      = return n
eval (Add e e )   = do a <- eval e
                       b <- eval e 0
                       return (a + b)
eval (Var v )     = do s <- get
                       return (fromJust $ lookup v s)
eval (Assign v e) = do a <- eval e
                       s <- get
                       put (insert v a s)
                       return a
\end{lstlisting}

\subsection{Mónada de estado, otra implementación}

\begin{lstlisting}
class Monad m -> MonadState s m | m -> s where
    get :: m s
    put :: s -> m ()

modify :: MonadState s m => (s -> s) -> m ()
modify f = do s <- get
              put (f s)

instance MonadState s (State s) where
    get   = State $ \s -> (s, s)
    pu    t s = State $ \_ -> ((), s)
\end{lstlisting}

\subsection{Mónada Lista}

\begin{lstlisting}
instance Monad [] where
return x = [x]
xs >>= f = [y | x <- xs, y <- f x]
            -- concat (map f xs)
\end{lstlisting}

Ejemplo: Suma de todos los pares de valores de dos listas

\begin{lstlisting}
sumnd :: Num a => [a] -> [a] -> [a]
sumnd xs ys = do x <- xs
                 y <- ys
                 return (x + y)
                 
-- Luego, 
-- >> sumnd [1,3] [4, 7]
--    [5, 8, 7, 10]     
\end{lstlisting}

\section{Parsers Monádicos}\label{sec:parsers_monadicos}

\subsection{Mónada de Parsing}

\begin{lstlisting}
newtype Parser a = P (String -> [(a, String)])

runP :: Parser a -> String -> [(a, String)]
runP (P p) = p

instance Monad Parser where
return a    = P $ \cs -> [(a, cs)]
(P p) >>= f = P $ \cs ->
                  concat [runP (f a) cs' | (a, cs') <- p cs]
\end{lstlisting}

\subsection{Parsing: cobinadores básicos}

\begin{lstlisting}
pFail :: Parser a
pFail = P $ \cs -> []

item :: Parser Char
item = P $ \cs -> case cs of 
    ""     -> []
    (c:cs) -> [(c, cs)]

pSat :: (Char -> Bool) -> Parser Char
pSat p = do c <- item
            if p c then return c else pFail

pSym :: Char -> Parser Char
pSym c = pSat (== c)
\end{lstlisting}

\imp{Definición}: Llamammos \imp{section} a una función que conoce su segundo argumento pero no el primero.

\subsection{Parsing: Alternativa}

\begin{lstlisting}
(<|>) :: Parser a -> Parser a -> Parser a
(P p) <|> (P q) = P $ \cs -> p cs ++ q cs


-- Otra forma de definir el operador de alternativa:

(P p) <|> (P q) = P $ \cs -> case p cs ++ q cs of
                                 []       -> []
                                 (x : xs) -> [x]
\end{lstlisting}

\newpage

\subsection{Parsing: many y some}

\begin{lstlisting}
-- p* (many) cero o más veces p

pList :: Parser a -> Parser [a]
pList p = do a <- p
             as <- pList p
             return (a:as)
             <|>
             return []

-- p+ (some) una o más veces p

pListP :: Parser a -> Parser [a]
pListP p = do a <- p
              as <- pList p
              return (a:as)
\end{lstlisting}

\subsubsection{Ejemplo: digits}

\begin{lstlisting}
digit :: Parser Int
digit = do c <- pSat isDigit
           return (ord c - ord '0')

isDigit c = (c >= '0') && (c <= '9')

digits :: Parser [Int]
digits = pListP digit

sumDigits :: Parser Int
sumDigits = do ds <- digits
               return (sum ds)
\end{lstlisting}

\subsubsection{Ejemplo: number}

\begin{lstlisting}
number :: Parser Int
number = do d <- digit
            number' d

number' :: Int -> Parser Int
number' n = do d <- digit
               number' (n * 10 + d)
            <|>
            return n

-- Esto equivale a la siguente definición:

number = do (d:ds) <- digits
            return (foldl (𐃏) d ds)
  where
    n 𐃏 d = n * 10 + d
\end{lstlisting}

\newpage

\subsection{Parser para expresiones}

Queremos parsear una expresión y retornar el correspondiente árbol
de sintaxis abstracta (AST) de tipo:

\begin{lstlisting}
data Expr = Val Int | Add Expr Expr

-- Que tal este parser?

expr :: Parser Expr
expr = do e1 <- expr
         pSym '+'
         e2 <- expr
         return (Add e1 e2)
       <|>
       do n <- number
          return (Val n)
\end{lstlisting}

\imp{Nota}: Diverge! La recursividad a la izquierda hace que entre en loop.

Para eliminar la recursión a la izquierda debemos basarnos en la
siguiente gramática:
\begin{center}
\texttt{e ::= n + e | n}
\end{center}
\indent \indent El parser queda entonces de la siguiente forma:
\begin{lstlisting}
expr :: Parser Expr
expr = do n <- number
          pSym '+'
          e <- expr
          return (Add (Val n) e)
       <|>
       do n <- number
          return (Val n)
\end{lstlisting}

\section{Parsing y evaluación de expresiones}

\begin{lstlisting}
evalExpr = do e <- expr
              return (eval e)
\end{lstlisting}
Es posible fusionar las definiciones de eval y expr y obtener una definición de evalExp que computa directamente el valor de la expresión parseada sin generar el AST intermedio:
\begin{lstlisting}
evalExpr :: Parser Int
evalExpr = do n <- number
              pSym '+'
              m <- evalExpr
              return (n + m)
           <|>
           number
\end{lstlisting}

\newpage

\section{Parser de un nano XML}

\begin{lstlisting}
data XML = Tag Char [XML]

xml :: Parser XML
xml = do -- se parsea el tag de apertura
         pSym '<'
         name <- item
         pSym '>'
            -- se parsea la lista de XMLs internos
         xmls <- pList xml
            -- se parsea el tag de cierre
         pSym '<'
         pSym '/'
         pSym name -- se utiliza nombre del tag de apertura
         pSym '>'
         return (Tag name xmls)
\end{lstlisting}

\end{document}